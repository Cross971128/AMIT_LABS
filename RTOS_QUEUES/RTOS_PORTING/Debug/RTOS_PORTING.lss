
RTOS_PORTING.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001dac  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000001a  00800060  00001dac  00001e40  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000644  0080007a  0080007a  00001e5a  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00001e5a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001eb8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003c0  00000000  00000000  00001ef4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000049ff  00000000  00000000  000022b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001321  00000000  00000000  00006cb3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002806  00000000  00000000  00007fd4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000b1c  00000000  00000000  0000a7dc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000014fe  00000000  00000000  0000b2f8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000048b8  00000000  00000000  0000c7f6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000438  00000000  00000000  000110ae  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 5b 04 	jmp	0x8b6	; 0x8b6 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec ea       	ldi	r30, 0xAC	; 172
      68:	fd e1       	ldi	r31, 0x1D	; 29
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	aa 37       	cpi	r26, 0x7A	; 122
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	26 e0       	ldi	r18, 0x06	; 6
      78:	aa e7       	ldi	r26, 0x7A	; 122
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ae 3b       	cpi	r26, 0xBE	; 190
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 d3 02 	call	0x5a6	; 0x5a6 <main>
      8a:	0c 94 d4 0e 	jmp	0x1da8	; 0x1da8 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      92:	0f 93       	push	r16
      94:	1f 93       	push	r17
      96:	cf 93       	push	r28
      98:	df 93       	push	r29
      9a:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
      9c:	0e 94 31 09 	call	0x1262	; 0x1262 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
      a0:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__data_end>
      a4:	81 11       	cpse	r24, r1
      a6:	1d c0       	rjmp	.+58     	; 0xe2 <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
      a8:	ef e7       	ldi	r30, 0x7F	; 127
      aa:	f0 e0       	ldi	r31, 0x00	; 0
      ac:	84 e8       	ldi	r24, 0x84	; 132
      ae:	90 e0       	ldi	r25, 0x00	; 0
      b0:	91 83       	std	Z+1, r25	; 0x01
      b2:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
      b4:	13 82       	std	Z+3, r1	; 0x03
      b6:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
      b8:	eb e7       	ldi	r30, 0x7B	; 123
      ba:	f0 e0       	ldi	r31, 0x00	; 0
      bc:	8b ed       	ldi	r24, 0xDB	; 219
      be:	95 e0       	ldi	r25, 0x05	; 5
      c0:	93 83       	std	Z+3, r25	; 0x03
      c2:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
      c4:	11 82       	std	Z+1, r1	; 0x01
      c6:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
      c8:	a3 e8       	ldi	r26, 0x83	; 131
      ca:	b0 e0       	ldi	r27, 0x00	; 0
      cc:	14 96       	adiw	r26, 0x04	; 4
      ce:	9c 93       	st	X, r25
      d0:	8e 93       	st	-X, r24
      d2:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
      d4:	12 96       	adiw	r26, 0x02	; 2
      d6:	fc 93       	st	X, r31
      d8:	ee 93       	st	-X, r30
      da:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
      dc:	81 e0       	ldi	r24, 0x01	; 1
      de:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
      e2:	20 97       	sbiw	r28, 0x00	; 0
      e4:	09 f4       	brne	.+2      	; 0xe8 <pvPortMalloc+0x56>
      e6:	5f c0       	rjmp	.+190    	; 0x1a6 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
      e8:	9e 01       	movw	r18, r28
      ea:	2c 5f       	subi	r18, 0xFC	; 252
      ec:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
      ee:	23 96       	adiw	r28, 0x03	; 3
      f0:	ca 3d       	cpi	r28, 0xDA	; 218
      f2:	d5 40       	sbci	r29, 0x05	; 5
      f4:	08 f0       	brcs	.+2      	; 0xf8 <pvPortMalloc+0x66>
      f6:	5a c0       	rjmp	.+180    	; 0x1ac <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
      f8:	e0 91 7f 00 	lds	r30, 0x007F	; 0x80007f <xStart>
      fc:	f0 91 80 00 	lds	r31, 0x0080	; 0x800080 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     100:	af e7       	ldi	r26, 0x7F	; 127
     102:	b0 e0       	ldi	r27, 0x00	; 0
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     104:	02 c0       	rjmp	.+4      	; 0x10a <pvPortMalloc+0x78>
     106:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     108:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     10a:	82 81       	ldd	r24, Z+2	; 0x02
     10c:	93 81       	ldd	r25, Z+3	; 0x03
     10e:	82 17       	cp	r24, r18
     110:	93 07       	cpc	r25, r19
     112:	20 f4       	brcc	.+8      	; 0x11c <pvPortMalloc+0x8a>
     114:	80 81       	ld	r24, Z
     116:	91 81       	ldd	r25, Z+1	; 0x01
     118:	00 97       	sbiw	r24, 0x00	; 0
     11a:	a9 f7       	brne	.-22     	; 0x106 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     11c:	c0 e0       	ldi	r28, 0x00	; 0
     11e:	eb 37       	cpi	r30, 0x7B	; 123
     120:	fc 07       	cpc	r31, r28
     122:	09 f4       	brne	.+2      	; 0x126 <pvPortMalloc+0x94>
     124:	46 c0       	rjmp	.+140    	; 0x1b2 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     126:	cd 91       	ld	r28, X+
     128:	dc 91       	ld	r29, X
     12a:	11 97       	sbiw	r26, 0x01	; 1
     12c:	8e 01       	movw	r16, r28
     12e:	0c 5f       	subi	r16, 0xFC	; 252
     130:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     132:	80 81       	ld	r24, Z
     134:	91 81       	ldd	r25, Z+1	; 0x01
     136:	8d 93       	st	X+, r24
     138:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     13a:	82 81       	ldd	r24, Z+2	; 0x02
     13c:	93 81       	ldd	r25, Z+3	; 0x03
     13e:	82 1b       	sub	r24, r18
     140:	93 0b       	sbc	r25, r19
     142:	89 30       	cpi	r24, 0x09	; 9
     144:	91 05       	cpc	r25, r1
     146:	10 f1       	brcs	.+68     	; 0x18c <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     148:	bf 01       	movw	r22, r30
     14a:	62 0f       	add	r22, r18
     14c:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     14e:	db 01       	movw	r26, r22
     150:	13 96       	adiw	r26, 0x03	; 3
     152:	9c 93       	st	X, r25
     154:	8e 93       	st	-X, r24
     156:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     158:	33 83       	std	Z+3, r19	; 0x03
     15a:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     15c:	12 96       	adiw	r26, 0x02	; 2
     15e:	4d 91       	ld	r20, X+
     160:	5c 91       	ld	r21, X
     162:	13 97       	sbiw	r26, 0x03	; 3
     164:	8f e7       	ldi	r24, 0x7F	; 127
     166:	90 e0       	ldi	r25, 0x00	; 0
     168:	01 c0       	rjmp	.+2      	; 0x16c <pvPortMalloc+0xda>
     16a:	cd 01       	movw	r24, r26
     16c:	ec 01       	movw	r28, r24
     16e:	a8 81       	ld	r26, Y
     170:	b9 81       	ldd	r27, Y+1	; 0x01
     172:	12 96       	adiw	r26, 0x02	; 2
     174:	2d 91       	ld	r18, X+
     176:	3c 91       	ld	r19, X
     178:	13 97       	sbiw	r26, 0x03	; 3
     17a:	24 17       	cp	r18, r20
     17c:	35 07       	cpc	r19, r21
     17e:	a8 f3       	brcs	.-22     	; 0x16a <pvPortMalloc+0xd8>
     180:	eb 01       	movw	r28, r22
     182:	b9 83       	std	Y+1, r27	; 0x01
     184:	a8 83       	st	Y, r26
     186:	dc 01       	movw	r26, r24
     188:	6d 93       	st	X+, r22
     18a:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     18c:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     190:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     194:	22 81       	ldd	r18, Z+2	; 0x02
     196:	33 81       	ldd	r19, Z+3	; 0x03
     198:	82 1b       	sub	r24, r18
     19a:	93 0b       	sbc	r25, r19
     19c:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     1a0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
     1a4:	08 c0       	rjmp	.+16     	; 0x1b6 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     1a6:	00 e0       	ldi	r16, 0x00	; 0
     1a8:	10 e0       	ldi	r17, 0x00	; 0
     1aa:	05 c0       	rjmp	.+10     	; 0x1b6 <pvPortMalloc+0x124>
     1ac:	00 e0       	ldi	r16, 0x00	; 0
     1ae:	10 e0       	ldi	r17, 0x00	; 0
     1b0:	02 c0       	rjmp	.+4      	; 0x1b6 <pvPortMalloc+0x124>
     1b2:	00 e0       	ldi	r16, 0x00	; 0
     1b4:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     1b6:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     1ba:	c8 01       	movw	r24, r16
     1bc:	df 91       	pop	r29
     1be:	cf 91       	pop	r28
     1c0:	1f 91       	pop	r17
     1c2:	0f 91       	pop	r16
     1c4:	08 95       	ret

000001c6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     1c6:	0f 93       	push	r16
     1c8:	1f 93       	push	r17
     1ca:	cf 93       	push	r28
     1cc:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     1ce:	00 97       	sbiw	r24, 0x00	; 0
     1d0:	41 f1       	breq	.+80     	; 0x222 <vPortFree+0x5c>
     1d2:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     1d4:	8c 01       	movw	r16, r24
     1d6:	04 50       	subi	r16, 0x04	; 4
     1d8:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     1da:	0e 94 31 09 	call	0x1262	; 0x1262 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     1de:	f8 01       	movw	r30, r16
     1e0:	42 81       	ldd	r20, Z+2	; 0x02
     1e2:	53 81       	ldd	r21, Z+3	; 0x03
     1e4:	af e7       	ldi	r26, 0x7F	; 127
     1e6:	b0 e0       	ldi	r27, 0x00	; 0
     1e8:	01 c0       	rjmp	.+2      	; 0x1ec <vPortFree+0x26>
     1ea:	df 01       	movw	r26, r30
     1ec:	ed 91       	ld	r30, X+
     1ee:	fc 91       	ld	r31, X
     1f0:	11 97       	sbiw	r26, 0x01	; 1
     1f2:	22 81       	ldd	r18, Z+2	; 0x02
     1f4:	33 81       	ldd	r19, Z+3	; 0x03
     1f6:	24 17       	cp	r18, r20
     1f8:	35 07       	cpc	r19, r21
     1fa:	b8 f3       	brcs	.-18     	; 0x1ea <vPortFree+0x24>
     1fc:	24 97       	sbiw	r28, 0x04	; 4
     1fe:	f9 83       	std	Y+1, r31	; 0x01
     200:	e8 83       	st	Y, r30
     202:	0d 93       	st	X+, r16
     204:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     206:	20 91 60 00 	lds	r18, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     20a:	30 91 61 00 	lds	r19, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     20e:	8a 81       	ldd	r24, Y+2	; 0x02
     210:	9b 81       	ldd	r25, Y+3	; 0x03
     212:	82 0f       	add	r24, r18
     214:	93 1f       	adc	r25, r19
     216:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     21a:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     21e:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <xTaskResumeAll>
	}
}
     222:	df 91       	pop	r29
     224:	cf 91       	pop	r28
     226:	1f 91       	pop	r17
     228:	0f 91       	pop	r16
     22a:	08 95       	ret

0000022c <KeyPad_getPressedKey>:
		{
			/*
			 * each time only one of the column pins will be output and
			 * the rest will be input pins include the row pins
			 */
			DDRA = (0b00010000<<col);
     22c:	e0 e1       	ldi	r30, 0x10	; 16
     22e:	f0 e0       	ldi	r31, 0x00	; 0
 */
static unsigned char KeyPad_4x3_adjustKeyNumber(unsigned char button_number);


/************************** Functions Definitions **********************/
unsigned char KeyPad_getPressedKey(void){
     230:	60 e0       	ldi	r22, 0x00	; 0
     232:	70 e0       	ldi	r23, 0x00	; 0
     234:	86 2f       	mov	r24, r22
		{
			/*
			 * each time only one of the column pins will be output and
			 * the rest will be input pins include the row pins
			 */
			DDRA = (0b00010000<<col);
     236:	9f 01       	movw	r18, r30
     238:	06 2e       	mov	r0, r22
     23a:	02 c0       	rjmp	.+4      	; 0x240 <KeyPad_getPressedKey+0x14>
     23c:	22 0f       	add	r18, r18
     23e:	33 1f       	adc	r19, r19
     240:	0a 94       	dec	r0
     242:	e2 f7       	brpl	.-8      	; 0x23c <KeyPad_getPressedKey+0x10>
     244:	2a bb       	out	0x1a, r18	; 26
			/*
			 * clear the output pin column in this trace and enable the internal
			 * pull up resistors for the rows pins
			 */
			PORTA = (~(0b00010000<<col)); //11101111
     246:	20 95       	com	r18
     248:	2b bb       	out	0x1b, r18	; 27

			for(row=0;row<N_row;row++) /* loop for rows */
			{
				if(!(PINA & (1<<row))) /* if the switch is press in this row */
     24a:	c8 9b       	sbis	0x19, 0	; 25
     24c:	0e c0       	rjmp	.+28     	; 0x26a <KeyPad_getPressedKey+0x3e>
     24e:	41 e0       	ldi	r20, 0x01	; 1
     250:	50 e0       	ldi	r21, 0x00	; 0
     252:	94 2f       	mov	r25, r20
     254:	29 b3       	in	r18, 0x19	; 25
     256:	30 e0       	ldi	r19, 0x00	; 0
     258:	04 2e       	mov	r0, r20
     25a:	02 c0       	rjmp	.+4      	; 0x260 <KeyPad_getPressedKey+0x34>
     25c:	35 95       	asr	r19
     25e:	27 95       	ror	r18
     260:	0a 94       	dec	r0
     262:	e2 f7       	brpl	.-8      	; 0x25c <KeyPad_getPressedKey+0x30>
     264:	20 fd       	sbrc	r18, 0
     266:	14 c0       	rjmp	.+40     	; 0x290 <KeyPad_getPressedKey+0x64>
     268:	01 c0       	rjmp	.+2      	; 0x26c <KeyPad_getPressedKey+0x40>
			 * clear the output pin column in this trace and enable the internal
			 * pull up resistors for the rows pins
			 */
			PORTA = (~(0b00010000<<col)); //11101111

			for(row=0;row<N_row;row++) /* loop for rows */
     26a:	90 e0       	ldi	r25, 0x00	; 0
			{
				if(!(PINA & (1<<row))) /* if the switch is press in this row */
				{
						return KeyPad_4x3_adjustKeyNumber((row*N_col)+col+1);
     26c:	8f 5f       	subi	r24, 0xFF	; 255
     26e:	29 2f       	mov	r18, r25
     270:	22 0f       	add	r18, r18
     272:	92 0f       	add	r25, r18
     274:	89 0f       	add	r24, r25
}


static unsigned char KeyPad_4x3_adjustKeyNumber(unsigned char button_number)
{
	switch(button_number)
     276:	8b 30       	cpi	r24, 0x0B	; 11
     278:	29 f0       	breq	.+10     	; 0x284 <KeyPad_getPressedKey+0x58>
     27a:	8c 30       	cpi	r24, 0x0C	; 12
     27c:	29 f0       	breq	.+10     	; 0x288 <KeyPad_getPressedKey+0x5c>
     27e:	8a 30       	cpi	r24, 0x0A	; 10
     280:	91 f4       	brne	.+36     	; 0x2a6 <KeyPad_getPressedKey+0x7a>
     282:	04 c0       	rjmp	.+8      	; 0x28c <KeyPad_getPressedKey+0x60>
	{
		case 10: return '*';
				 break;
		case 11: return 0;
     284:	80 e0       	ldi	r24, 0x00	; 0
     286:	08 95       	ret
				 break;
		case 12: return '#';
     288:	83 e2       	ldi	r24, 0x23	; 35
     28a:	08 95       	ret

static unsigned char KeyPad_4x3_adjustKeyNumber(unsigned char button_number)
{
	switch(button_number)
	{
		case 10: return '*';
     28c:	8a e2       	ldi	r24, 0x2A	; 42

			for(row=0;row<N_row;row++) /* loop for rows */
			{
				if(!(PINA & (1<<row))) /* if the switch is press in this row */
				{
						return KeyPad_4x3_adjustKeyNumber((row*N_col)+col+1);
     28e:	08 95       	ret
     290:	4f 5f       	subi	r20, 0xFF	; 255
     292:	5f 4f       	sbci	r21, 0xFF	; 255
			 * clear the output pin column in this trace and enable the internal
			 * pull up resistors for the rows pins
			 */
			PORTA = (~(0b00010000<<col)); //11101111

			for(row=0;row<N_row;row++) /* loop for rows */
     294:	44 30       	cpi	r20, 0x04	; 4
     296:	51 05       	cpc	r21, r1
     298:	e1 f6       	brne	.-72     	; 0x252 <KeyPad_getPressedKey+0x26>
     29a:	6f 5f       	subi	r22, 0xFF	; 255
     29c:	7f 4f       	sbci	r23, 0xFF	; 255
/************************** Functions Definitions **********************/
unsigned char KeyPad_getPressedKey(void){
	unsigned char col,row;
	while(1)
	{
		for(col=0;col<N_col;col++) /* loop for columns */
     29e:	63 30       	cpi	r22, 0x03	; 3
     2a0:	71 05       	cpc	r23, r1
     2a2:	41 f6       	brne	.-112    	; 0x234 <KeyPad_getPressedKey+0x8>
     2a4:	c5 cf       	rjmp	.-118    	; 0x230 <KeyPad_getPressedKey+0x4>
						return KeyPad_4x3_adjustKeyNumber((row*N_col)+col+1);
				}
			}
		}
	}
}
     2a6:	08 95       	ret

000002a8 <LCD_sendCommand>:

void LCD_displayStringRowColumn(unsigned char row,unsigned char col,const char *Str)
{
	LCD_goToRowColumn(row,col); /* go to to the required LCD position */
	LCD_displayString(Str); /* display the string */
}
     2a8:	94 98       	cbi	0x12, 4	; 18
     2aa:	95 98       	cbi	0x12, 5	; 18
     2ac:	85 bb       	out	0x15, r24	; 21
     2ae:	89 ef       	ldi	r24, 0xF9	; 249
     2b0:	90 e0       	ldi	r25, 0x00	; 0
     2b2:	01 97       	sbiw	r24, 0x01	; 1
     2b4:	f1 f7       	brne	.-4      	; 0x2b2 <LCD_sendCommand+0xa>
     2b6:	00 c0       	rjmp	.+0      	; 0x2b8 <LCD_sendCommand+0x10>
     2b8:	00 00       	nop
     2ba:	96 9a       	sbi	0x12, 6	; 18
     2bc:	89 ef       	ldi	r24, 0xF9	; 249
     2be:	90 e0       	ldi	r25, 0x00	; 0
     2c0:	01 97       	sbiw	r24, 0x01	; 1
     2c2:	f1 f7       	brne	.-4      	; 0x2c0 <LCD_sendCommand+0x18>
     2c4:	00 c0       	rjmp	.+0      	; 0x2c6 <LCD_sendCommand+0x1e>
     2c6:	00 00       	nop
     2c8:	96 98       	cbi	0x12, 6	; 18
     2ca:	89 ef       	ldi	r24, 0xF9	; 249
     2cc:	90 e0       	ldi	r25, 0x00	; 0
     2ce:	01 97       	sbiw	r24, 0x01	; 1
     2d0:	f1 f7       	brne	.-4      	; 0x2ce <LCD_sendCommand+0x26>
     2d2:	00 c0       	rjmp	.+0      	; 0x2d4 <LCD_sendCommand+0x2c>
     2d4:	00 00       	nop
     2d6:	08 95       	ret

000002d8 <LCD_init>:
     2d8:	8f ef       	ldi	r24, 0xFF	; 255
     2da:	84 bb       	out	0x14, r24	; 20
     2dc:	81 b3       	in	r24, 0x11	; 17
     2de:	80 67       	ori	r24, 0x70	; 112
     2e0:	81 bb       	out	0x11, r24	; 17
     2e2:	88 e3       	ldi	r24, 0x38	; 56
     2e4:	0e 94 54 01 	call	0x2a8	; 0x2a8 <LCD_sendCommand>
     2e8:	8c e0       	ldi	r24, 0x0C	; 12
     2ea:	0e 94 54 01 	call	0x2a8	; 0x2a8 <LCD_sendCommand>
     2ee:	81 e0       	ldi	r24, 0x01	; 1
     2f0:	0e 94 54 01 	call	0x2a8	; 0x2a8 <LCD_sendCommand>
     2f4:	08 95       	ret

000002f6 <LCD_displayCharacter>:
     2f6:	94 9a       	sbi	0x12, 4	; 18
     2f8:	95 98       	cbi	0x12, 5	; 18
     2fa:	96 9a       	sbi	0x12, 6	; 18
     2fc:	e9 ef       	ldi	r30, 0xF9	; 249
     2fe:	f0 e0       	ldi	r31, 0x00	; 0
     300:	31 97       	sbiw	r30, 0x01	; 1
     302:	f1 f7       	brne	.-4      	; 0x300 <LCD_displayCharacter+0xa>
     304:	00 c0       	rjmp	.+0      	; 0x306 <LCD_displayCharacter+0x10>
     306:	00 00       	nop
     308:	85 bb       	out	0x15, r24	; 21
     30a:	89 ef       	ldi	r24, 0xF9	; 249
     30c:	90 e0       	ldi	r25, 0x00	; 0
     30e:	01 97       	sbiw	r24, 0x01	; 1
     310:	f1 f7       	brne	.-4      	; 0x30e <LCD_displayCharacter+0x18>
     312:	00 c0       	rjmp	.+0      	; 0x314 <LCD_displayCharacter+0x1e>
     314:	00 00       	nop
     316:	96 9a       	sbi	0x12, 6	; 18
     318:	e9 ef       	ldi	r30, 0xF9	; 249
     31a:	f0 e0       	ldi	r31, 0x00	; 0
     31c:	31 97       	sbiw	r30, 0x01	; 1
     31e:	f1 f7       	brne	.-4      	; 0x31c <LCD_displayCharacter+0x26>
     320:	00 c0       	rjmp	.+0      	; 0x322 <LCD_displayCharacter+0x2c>
     322:	00 00       	nop
     324:	96 98       	cbi	0x12, 6	; 18
     326:	89 ef       	ldi	r24, 0xF9	; 249
     328:	90 e0       	ldi	r25, 0x00	; 0
     32a:	01 97       	sbiw	r24, 0x01	; 1
     32c:	f1 f7       	brne	.-4      	; 0x32a <LCD_displayCharacter+0x34>
     32e:	00 c0       	rjmp	.+0      	; 0x330 <LCD_displayCharacter+0x3a>
     330:	00 00       	nop
     332:	08 95       	ret

00000334 <LCD_displayString>:
     334:	0f 93       	push	r16
     336:	1f 93       	push	r17
     338:	cf 93       	push	r28
     33a:	fc 01       	movw	r30, r24
     33c:	80 81       	ld	r24, Z
     33e:	88 23       	and	r24, r24
     340:	59 f0       	breq	.+22     	; 0x358 <LCD_displayString+0x24>
     342:	8f 01       	movw	r16, r30
     344:	c0 e0       	ldi	r28, 0x00	; 0
     346:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <LCD_displayCharacter>
     34a:	cf 5f       	subi	r28, 0xFF	; 255
     34c:	f8 01       	movw	r30, r16
     34e:	ec 0f       	add	r30, r28
     350:	f1 1d       	adc	r31, r1
     352:	80 81       	ld	r24, Z
     354:	81 11       	cpse	r24, r1
     356:	f7 cf       	rjmp	.-18     	; 0x346 <LCD_displayString+0x12>
     358:	cf 91       	pop	r28
     35a:	1f 91       	pop	r17
     35c:	0f 91       	pop	r16
     35e:	08 95       	ret

00000360 <LCD_goToRowColumn>:
     360:	88 23       	and	r24, r24
     362:	19 f0       	breq	.+6      	; 0x36a <LCD_goToRowColumn+0xa>
     364:	81 30       	cpi	r24, 0x01	; 1
     366:	19 f0       	breq	.+6      	; 0x36e <LCD_goToRowColumn+0xe>
     368:	04 c0       	rjmp	.+8      	; 0x372 <LCD_goToRowColumn+0x12>
     36a:	96 2f       	mov	r25, r22
     36c:	02 c0       	rjmp	.+4      	; 0x372 <LCD_goToRowColumn+0x12>
     36e:	90 e4       	ldi	r25, 0x40	; 64
     370:	96 0f       	add	r25, r22
     372:	89 2f       	mov	r24, r25
     374:	80 68       	ori	r24, 0x80	; 128
     376:	0e 94 54 01 	call	0x2a8	; 0x2a8 <LCD_sendCommand>
     37a:	08 95       	ret

0000037c <LCD_intgerToString>:

void LCD_intgerToString(int data) // from 500 to "500"
{
     37c:	cf 93       	push	r28
     37e:	df 93       	push	r29
     380:	cd b7       	in	r28, 0x3d	; 61
     382:	de b7       	in	r29, 0x3e	; 62
     384:	60 97       	sbiw	r28, 0x10	; 16
     386:	0f b6       	in	r0, 0x3f	; 63
     388:	f8 94       	cli
     38a:	de bf       	out	0x3e, r29	; 62
     38c:	0f be       	out	0x3f, r0	; 63
     38e:	cd bf       	out	0x3d, r28	; 61
   char buff[16]; /* String to hold the ascii result */
   itoa(data,buff,10); /* 10 for decimal */
     390:	4a e0       	ldi	r20, 0x0A	; 10
     392:	50 e0       	ldi	r21, 0x00	; 0
     394:	be 01       	movw	r22, r28
     396:	6f 5f       	subi	r22, 0xFF	; 255
     398:	7f 4f       	sbci	r23, 0xFF	; 255
     39a:	0e 94 aa 0b 	call	0x1754	; 0x1754 <itoa>
   LCD_displayString(buff);
     39e:	ce 01       	movw	r24, r28
     3a0:	01 96       	adiw	r24, 0x01	; 1
     3a2:	0e 94 9a 01 	call	0x334	; 0x334 <LCD_displayString>
}
     3a6:	60 96       	adiw	r28, 0x10	; 16
     3a8:	0f b6       	in	r0, 0x3f	; 63
     3aa:	f8 94       	cli
     3ac:	de bf       	out	0x3e, r29	; 62
     3ae:	0f be       	out	0x3f, r0	; 63
     3b0:	cd bf       	out	0x3d, r28	; 61
     3b2:	df 91       	pop	r29
     3b4:	cf 91       	pop	r28
     3b6:	08 95       	ret

000003b8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     3b8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     3ba:	03 96       	adiw	r24, 0x03	; 3
     3bc:	92 83       	std	Z+2, r25	; 0x02
     3be:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     3c0:	2f ef       	ldi	r18, 0xFF	; 255
     3c2:	3f ef       	ldi	r19, 0xFF	; 255
     3c4:	34 83       	std	Z+4, r19	; 0x04
     3c6:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     3c8:	96 83       	std	Z+6, r25	; 0x06
     3ca:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     3cc:	90 87       	std	Z+8, r25	; 0x08
     3ce:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     3d0:	10 82       	st	Z, r1
     3d2:	08 95       	ret

000003d4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     3d4:	fc 01       	movw	r30, r24
     3d6:	11 86       	std	Z+9, r1	; 0x09
     3d8:	10 86       	std	Z+8, r1	; 0x08
     3da:	08 95       	ret

000003dc <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     3dc:	cf 93       	push	r28
     3de:	df 93       	push	r29
     3e0:	9c 01       	movw	r18, r24
     3e2:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     3e4:	dc 01       	movw	r26, r24
     3e6:	11 96       	adiw	r26, 0x01	; 1
     3e8:	cd 91       	ld	r28, X+
     3ea:	dc 91       	ld	r29, X
     3ec:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     3ee:	d3 83       	std	Z+3, r29	; 0x03
     3f0:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     3f2:	8c 81       	ldd	r24, Y+4	; 0x04
     3f4:	9d 81       	ldd	r25, Y+5	; 0x05
     3f6:	95 83       	std	Z+5, r25	; 0x05
     3f8:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     3fa:	8c 81       	ldd	r24, Y+4	; 0x04
     3fc:	9d 81       	ldd	r25, Y+5	; 0x05
     3fe:	dc 01       	movw	r26, r24
     400:	13 96       	adiw	r26, 0x03	; 3
     402:	7c 93       	st	X, r23
     404:	6e 93       	st	-X, r22
     406:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     408:	7d 83       	std	Y+5, r23	; 0x05
     40a:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     40c:	31 87       	std	Z+9, r19	; 0x09
     40e:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     410:	f9 01       	movw	r30, r18
     412:	80 81       	ld	r24, Z
     414:	8f 5f       	subi	r24, 0xFF	; 255
     416:	80 83       	st	Z, r24
}
     418:	df 91       	pop	r29
     41a:	cf 91       	pop	r28
     41c:	08 95       	ret

0000041e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     41e:	cf 93       	push	r28
     420:	df 93       	push	r29
     422:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     424:	48 81       	ld	r20, Y
     426:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     428:	4f 3f       	cpi	r20, 0xFF	; 255
     42a:	2f ef       	ldi	r18, 0xFF	; 255
     42c:	52 07       	cpc	r21, r18
     42e:	21 f4       	brne	.+8      	; 0x438 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     430:	fc 01       	movw	r30, r24
     432:	a7 81       	ldd	r26, Z+7	; 0x07
     434:	b0 85       	ldd	r27, Z+8	; 0x08
     436:	0d c0       	rjmp	.+26     	; 0x452 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     438:	dc 01       	movw	r26, r24
     43a:	13 96       	adiw	r26, 0x03	; 3
     43c:	01 c0       	rjmp	.+2      	; 0x440 <vListInsert+0x22>
     43e:	df 01       	movw	r26, r30
     440:	12 96       	adiw	r26, 0x02	; 2
     442:	ed 91       	ld	r30, X+
     444:	fc 91       	ld	r31, X
     446:	13 97       	sbiw	r26, 0x03	; 3
     448:	20 81       	ld	r18, Z
     44a:	31 81       	ldd	r19, Z+1	; 0x01
     44c:	42 17       	cp	r20, r18
     44e:	53 07       	cpc	r21, r19
     450:	b0 f7       	brcc	.-20     	; 0x43e <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     452:	12 96       	adiw	r26, 0x02	; 2
     454:	ed 91       	ld	r30, X+
     456:	fc 91       	ld	r31, X
     458:	13 97       	sbiw	r26, 0x03	; 3
     45a:	fb 83       	std	Y+3, r31	; 0x03
     45c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     45e:	d5 83       	std	Z+5, r29	; 0x05
     460:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     462:	bd 83       	std	Y+5, r27	; 0x05
     464:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     466:	13 96       	adiw	r26, 0x03	; 3
     468:	dc 93       	st	X, r29
     46a:	ce 93       	st	-X, r28
     46c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     46e:	99 87       	std	Y+9, r25	; 0x09
     470:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     472:	fc 01       	movw	r30, r24
     474:	20 81       	ld	r18, Z
     476:	2f 5f       	subi	r18, 0xFF	; 255
     478:	20 83       	st	Z, r18
}
     47a:	df 91       	pop	r29
     47c:	cf 91       	pop	r28
     47e:	08 95       	ret

00000480 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     480:	cf 93       	push	r28
     482:	df 93       	push	r29
     484:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     486:	a0 85       	ldd	r26, Z+8	; 0x08
     488:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     48a:	c2 81       	ldd	r28, Z+2	; 0x02
     48c:	d3 81       	ldd	r29, Z+3	; 0x03
     48e:	84 81       	ldd	r24, Z+4	; 0x04
     490:	95 81       	ldd	r25, Z+5	; 0x05
     492:	9d 83       	std	Y+5, r25	; 0x05
     494:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     496:	c4 81       	ldd	r28, Z+4	; 0x04
     498:	d5 81       	ldd	r29, Z+5	; 0x05
     49a:	82 81       	ldd	r24, Z+2	; 0x02
     49c:	93 81       	ldd	r25, Z+3	; 0x03
     49e:	9b 83       	std	Y+3, r25	; 0x03
     4a0:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     4a2:	11 96       	adiw	r26, 0x01	; 1
     4a4:	8d 91       	ld	r24, X+
     4a6:	9c 91       	ld	r25, X
     4a8:	12 97       	sbiw	r26, 0x02	; 2
     4aa:	e8 17       	cp	r30, r24
     4ac:	f9 07       	cpc	r31, r25
     4ae:	31 f4       	brne	.+12     	; 0x4bc <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     4b0:	84 81       	ldd	r24, Z+4	; 0x04
     4b2:	95 81       	ldd	r25, Z+5	; 0x05
     4b4:	12 96       	adiw	r26, 0x02	; 2
     4b6:	9c 93       	st	X, r25
     4b8:	8e 93       	st	-X, r24
     4ba:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     4bc:	11 86       	std	Z+9, r1	; 0x09
     4be:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     4c0:	8c 91       	ld	r24, X
     4c2:	81 50       	subi	r24, 0x01	; 1
     4c4:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     4c6:	8c 91       	ld	r24, X
}
     4c8:	df 91       	pop	r29
     4ca:	cf 91       	pop	r28
     4cc:	08 95       	ret

000004ce <count_keypad>:
	{
		PORTC&=~(1<<PC7);
	}
	vTaskDelay(100/portTICK_PERIOD_MS);
	
	}
     4ce:	cf 93       	push	r28
     4d0:	df 93       	push	r29
     4d2:	1f 92       	push	r1
     4d4:	cd b7       	in	r28, 0x3d	; 61
     4d6:	de b7       	in	r29, 0x3e	; 62
     4d8:	19 82       	std	Y+1, r1	; 0x01
     4da:	0e 94 16 01 	call	0x22c	; 0x22c <KeyPad_getPressedKey>
     4de:	89 83       	std	Y+1, r24	; 0x01
     4e0:	8c e2       	ldi	r24, 0x2C	; 44
     4e2:	91 e0       	ldi	r25, 0x01	; 1
     4e4:	0e 94 71 0a 	call	0x14e2	; 0x14e2 <vTaskDelay>
     4e8:	20 e0       	ldi	r18, 0x00	; 0
     4ea:	44 e1       	ldi	r20, 0x14	; 20
     4ec:	50 e0       	ldi	r21, 0x00	; 0
     4ee:	be 01       	movw	r22, r28
     4f0:	6f 5f       	subi	r22, 0xFF	; 255
     4f2:	7f 4f       	sbci	r23, 0xFF	; 255
     4f4:	80 91 bc 06 	lds	r24, 0x06BC	; 0x8006bc <xQueue>
     4f8:	90 91 bd 06 	lds	r25, 0x06BD	; 0x8006bd <xQueue+0x1>
     4fc:	0e 94 8c 05 	call	0xb18	; 0xb18 <xQueueGenericSend>
     500:	ec cf       	rjmp	.-40     	; 0x4da <count_keypad+0xc>

00000502 <LCD_Display>:
     502:	cf 93       	push	r28
     504:	df 93       	push	r29
     506:	1f 92       	push	r1
     508:	cd b7       	in	r28, 0x3d	; 61
     50a:	de b7       	in	r29, 0x3e	; 62
     50c:	19 82       	std	Y+1, r1	; 0x01
     50e:	60 e0       	ldi	r22, 0x00	; 0
     510:	80 e0       	ldi	r24, 0x00	; 0
     512:	0e 94 b0 01 	call	0x360	; 0x360 <LCD_goToRowColumn>
     516:	4f ef       	ldi	r20, 0xFF	; 255
     518:	5f ef       	ldi	r21, 0xFF	; 255
     51a:	be 01       	movw	r22, r28
     51c:	6f 5f       	subi	r22, 0xFF	; 255
     51e:	7f 4f       	sbci	r23, 0xFF	; 255
     520:	80 91 bc 06 	lds	r24, 0x06BC	; 0x8006bc <xQueue>
     524:	90 91 bd 06 	lds	r25, 0x06BD	; 0x8006bd <xQueue+0x1>
     528:	0e 94 2d 06 	call	0xc5a	; 0xc5a <xQueueReceive>
     52c:	89 81       	ldd	r24, Y+1	; 0x01
     52e:	90 e0       	ldi	r25, 0x00	; 0
     530:	0e 94 be 01 	call	0x37c	; 0x37c <LCD_intgerToString>
     534:	84 e6       	ldi	r24, 0x64	; 100
     536:	90 e0       	ldi	r25, 0x00	; 0
     538:	0e 94 71 0a 	call	0x14e2	; 0x14e2 <vTaskDelay>
     53c:	e8 cf       	rjmp	.-48     	; 0x50e <LCD_Display+0xc>

0000053e <UART_TASK>:
     53e:	cf 93       	push	r28
     540:	df 93       	push	r29
     542:	00 d0       	rcall	.+0      	; 0x544 <UART_TASK+0x6>
     544:	1f 92       	push	r1
     546:	cd b7       	in	r28, 0x3d	; 61
     548:	de b7       	in	r29, 0x3e	; 62
     54a:	0e 94 80 0b 	call	0x1700	; 0x1700 <uartInit_test>
     54e:	19 82       	std	Y+1, r1	; 0x01
     550:	0f 2e       	mov	r0, r31
     552:	f2 e6       	ldi	r31, 0x62	; 98
     554:	ef 2e       	mov	r14, r31
     556:	f0 e0       	ldi	r31, 0x00	; 0
     558:	ff 2e       	mov	r15, r31
     55a:	f0 2d       	mov	r31, r0
     55c:	8e 01       	movw	r16, r28
     55e:	0e 5f       	subi	r16, 0xFE	; 254
     560:	1f 4f       	sbci	r17, 0xFF	; 255
     562:	4f ef       	ldi	r20, 0xFF	; 255
     564:	5f ef       	ldi	r21, 0xFF	; 255
     566:	be 01       	movw	r22, r28
     568:	6f 5f       	subi	r22, 0xFF	; 255
     56a:	7f 4f       	sbci	r23, 0xFF	; 255
     56c:	80 91 bc 06 	lds	r24, 0x06BC	; 0x8006bc <xQueue>
     570:	90 91 bd 06 	lds	r25, 0x06BD	; 0x8006bd <xQueue+0x1>
     574:	0e 94 c6 06 	call	0xd8c	; 0xd8c <xQueuePeek>
     578:	89 81       	ldd	r24, Y+1	; 0x01
     57a:	1f 92       	push	r1
     57c:	8f 93       	push	r24
     57e:	ff 92       	push	r15
     580:	ef 92       	push	r14
     582:	1f 93       	push	r17
     584:	0f 93       	push	r16
     586:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <sprintf>
     58a:	c8 01       	movw	r24, r16
     58c:	0e 94 8b 0b 	call	0x1716	; 0x1716 <UART_sendString>
     590:	84 e6       	ldi	r24, 0x64	; 100
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	0e 94 71 0a 	call	0x14e2	; 0x14e2 <vTaskDelay>
     598:	0f 90       	pop	r0
     59a:	0f 90       	pop	r0
     59c:	0f 90       	pop	r0
     59e:	0f 90       	pop	r0
     5a0:	0f 90       	pop	r0
     5a2:	0f 90       	pop	r0
     5a4:	de cf       	rjmp	.-68     	; 0x562 <UART_TASK+0x24>

000005a6 <main>:
	}
}
 int main()

 {
	LCD_init();
     5a6:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <LCD_init>
	xQueue = xQueueCreate(3,sizeof(int));
     5aa:	40 e0       	ldi	r20, 0x00	; 0
     5ac:	62 e0       	ldi	r22, 0x02	; 2
     5ae:	83 e0       	ldi	r24, 0x03	; 3
     5b0:	0e 94 5f 05 	call	0xabe	; 0xabe <xQueueGenericCreate>
     5b4:	90 93 bd 06 	sts	0x06BD, r25	; 0x8006bd <xQueue+0x1>
     5b8:	80 93 bc 06 	sts	0x06BC, r24	; 0x8006bc <xQueue>
	if(xQueue != NULL)
     5bc:	89 2b       	or	r24, r25
     5be:	21 f1       	breq	.+72     	; 0x608 <main+0x62>
	{
		//xTaskCreate(count,"count1",240,(void*)100,1,NULL);
		xTaskCreate(count_keypad,"keypad",240,NULL,1,NULL);
     5c0:	e1 2c       	mov	r14, r1
     5c2:	f1 2c       	mov	r15, r1
     5c4:	01 e0       	ldi	r16, 0x01	; 1
     5c6:	20 e0       	ldi	r18, 0x00	; 0
     5c8:	30 e0       	ldi	r19, 0x00	; 0
     5ca:	40 ef       	ldi	r20, 0xF0	; 240
     5cc:	50 e0       	ldi	r21, 0x00	; 0
     5ce:	65 e6       	ldi	r22, 0x65	; 101
     5d0:	70 e0       	ldi	r23, 0x00	; 0
     5d2:	87 e6       	ldi	r24, 0x67	; 103
     5d4:	92 e0       	ldi	r25, 0x02	; 2
     5d6:	0e 94 fa 07 	call	0xff4	; 0xff4 <xTaskCreate>
		//xTaskCreate(led,"led1",240,(void*)100,1,NULL);
		xTaskCreate(LCD_Display,"LCD",240,NULL,1,NULL);
     5da:	20 e0       	ldi	r18, 0x00	; 0
     5dc:	30 e0       	ldi	r19, 0x00	; 0
     5de:	40 ef       	ldi	r20, 0xF0	; 240
     5e0:	50 e0       	ldi	r21, 0x00	; 0
     5e2:	6c e6       	ldi	r22, 0x6C	; 108
     5e4:	70 e0       	ldi	r23, 0x00	; 0
     5e6:	81 e8       	ldi	r24, 0x81	; 129
     5e8:	92 e0       	ldi	r25, 0x02	; 2
     5ea:	0e 94 fa 07 	call	0xff4	; 0xff4 <xTaskCreate>
		xTaskCreate(UART_TASK,"UART",240,NULL,2,NULL);
     5ee:	02 e0       	ldi	r16, 0x02	; 2
     5f0:	20 e0       	ldi	r18, 0x00	; 0
     5f2:	30 e0       	ldi	r19, 0x00	; 0
     5f4:	40 ef       	ldi	r20, 0xF0	; 240
     5f6:	50 e0       	ldi	r21, 0x00	; 0
     5f8:	60 e7       	ldi	r22, 0x70	; 112
     5fa:	70 e0       	ldi	r23, 0x00	; 0
     5fc:	8f e9       	ldi	r24, 0x9F	; 159
     5fe:	92 e0       	ldi	r25, 0x02	; 2
     600:	0e 94 fa 07 	call	0xff4	; 0xff4 <xTaskCreate>
		vTaskStartScheduler();
     604:	0e 94 07 09 	call	0x120e	; 0x120e <vTaskStartScheduler>
     608:	ff cf       	rjmp	.-2      	; 0x608 <main+0x62>

0000060a <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     60a:	31 e1       	ldi	r19, 0x11	; 17
     60c:	fc 01       	movw	r30, r24
     60e:	30 83       	st	Z, r19
     610:	31 97       	sbiw	r30, 0x01	; 1
     612:	22 e2       	ldi	r18, 0x22	; 34
     614:	20 83       	st	Z, r18
     616:	31 97       	sbiw	r30, 0x01	; 1
     618:	a3 e3       	ldi	r26, 0x33	; 51
     61a:	a0 83       	st	Z, r26
     61c:	31 97       	sbiw	r30, 0x01	; 1
     61e:	60 83       	st	Z, r22
     620:	31 97       	sbiw	r30, 0x01	; 1
     622:	70 83       	st	Z, r23
     624:	31 97       	sbiw	r30, 0x01	; 1
     626:	10 82       	st	Z, r1
     628:	31 97       	sbiw	r30, 0x01	; 1
     62a:	60 e8       	ldi	r22, 0x80	; 128
     62c:	60 83       	st	Z, r22
     62e:	31 97       	sbiw	r30, 0x01	; 1
     630:	10 82       	st	Z, r1
     632:	31 97       	sbiw	r30, 0x01	; 1
     634:	62 e0       	ldi	r22, 0x02	; 2
     636:	60 83       	st	Z, r22
     638:	31 97       	sbiw	r30, 0x01	; 1
     63a:	63 e0       	ldi	r22, 0x03	; 3
     63c:	60 83       	st	Z, r22
     63e:	31 97       	sbiw	r30, 0x01	; 1
     640:	64 e0       	ldi	r22, 0x04	; 4
     642:	60 83       	st	Z, r22
     644:	31 97       	sbiw	r30, 0x01	; 1
     646:	65 e0       	ldi	r22, 0x05	; 5
     648:	60 83       	st	Z, r22
     64a:	31 97       	sbiw	r30, 0x01	; 1
     64c:	66 e0       	ldi	r22, 0x06	; 6
     64e:	60 83       	st	Z, r22
     650:	31 97       	sbiw	r30, 0x01	; 1
     652:	67 e0       	ldi	r22, 0x07	; 7
     654:	60 83       	st	Z, r22
     656:	31 97       	sbiw	r30, 0x01	; 1
     658:	68 e0       	ldi	r22, 0x08	; 8
     65a:	60 83       	st	Z, r22
     65c:	31 97       	sbiw	r30, 0x01	; 1
     65e:	69 e0       	ldi	r22, 0x09	; 9
     660:	60 83       	st	Z, r22
     662:	31 97       	sbiw	r30, 0x01	; 1
     664:	60 e1       	ldi	r22, 0x10	; 16
     666:	60 83       	st	Z, r22
     668:	31 97       	sbiw	r30, 0x01	; 1
     66a:	30 83       	st	Z, r19
     66c:	31 97       	sbiw	r30, 0x01	; 1
     66e:	32 e1       	ldi	r19, 0x12	; 18
     670:	30 83       	st	Z, r19
     672:	31 97       	sbiw	r30, 0x01	; 1
     674:	33 e1       	ldi	r19, 0x13	; 19
     676:	30 83       	st	Z, r19
     678:	31 97       	sbiw	r30, 0x01	; 1
     67a:	34 e1       	ldi	r19, 0x14	; 20
     67c:	30 83       	st	Z, r19
     67e:	31 97       	sbiw	r30, 0x01	; 1
     680:	35 e1       	ldi	r19, 0x15	; 21
     682:	30 83       	st	Z, r19
     684:	31 97       	sbiw	r30, 0x01	; 1
     686:	36 e1       	ldi	r19, 0x16	; 22
     688:	30 83       	st	Z, r19
     68a:	31 97       	sbiw	r30, 0x01	; 1
     68c:	37 e1       	ldi	r19, 0x17	; 23
     68e:	30 83       	st	Z, r19
     690:	31 97       	sbiw	r30, 0x01	; 1
     692:	38 e1       	ldi	r19, 0x18	; 24
     694:	30 83       	st	Z, r19
     696:	31 97       	sbiw	r30, 0x01	; 1
     698:	39 e1       	ldi	r19, 0x19	; 25
     69a:	30 83       	st	Z, r19
     69c:	31 97       	sbiw	r30, 0x01	; 1
     69e:	30 e2       	ldi	r19, 0x20	; 32
     6a0:	30 83       	st	Z, r19
     6a2:	31 97       	sbiw	r30, 0x01	; 1
     6a4:	31 e2       	ldi	r19, 0x21	; 33
     6a6:	30 83       	st	Z, r19
     6a8:	31 97       	sbiw	r30, 0x01	; 1
     6aa:	20 83       	st	Z, r18
     6ac:	31 97       	sbiw	r30, 0x01	; 1
     6ae:	23 e2       	ldi	r18, 0x23	; 35
     6b0:	20 83       	st	Z, r18
     6b2:	31 97       	sbiw	r30, 0x01	; 1
     6b4:	40 83       	st	Z, r20
     6b6:	31 97       	sbiw	r30, 0x01	; 1
     6b8:	50 83       	st	Z, r21
     6ba:	31 97       	sbiw	r30, 0x01	; 1
     6bc:	26 e2       	ldi	r18, 0x26	; 38
     6be:	20 83       	st	Z, r18
     6c0:	31 97       	sbiw	r30, 0x01	; 1
     6c2:	27 e2       	ldi	r18, 0x27	; 39
     6c4:	20 83       	st	Z, r18
     6c6:	31 97       	sbiw	r30, 0x01	; 1
     6c8:	28 e2       	ldi	r18, 0x28	; 40
     6ca:	20 83       	st	Z, r18
     6cc:	31 97       	sbiw	r30, 0x01	; 1
     6ce:	29 e2       	ldi	r18, 0x29	; 41
     6d0:	20 83       	st	Z, r18
     6d2:	31 97       	sbiw	r30, 0x01	; 1
     6d4:	20 e3       	ldi	r18, 0x30	; 48
     6d6:	20 83       	st	Z, r18
     6d8:	31 97       	sbiw	r30, 0x01	; 1
     6da:	21 e3       	ldi	r18, 0x31	; 49
     6dc:	20 83       	st	Z, r18
     6de:	86 97       	sbiw	r24, 0x26	; 38
     6e0:	08 95       	ret

000006e2 <xPortStartScheduler>:
     6e2:	1b bc       	out	0x2b, r1	; 43
     6e4:	89 ef       	ldi	r24, 0xF9	; 249
     6e6:	8a bd       	out	0x2a, r24	; 42
     6e8:	8b e0       	ldi	r24, 0x0B	; 11
     6ea:	8e bd       	out	0x2e, r24	; 46
     6ec:	89 b7       	in	r24, 0x39	; 57
     6ee:	80 61       	ori	r24, 0x10	; 16
     6f0:	89 bf       	out	0x39, r24	; 57
     6f2:	a0 91 ba 06 	lds	r26, 0x06BA	; 0x8006ba <pxCurrentTCB>
     6f6:	b0 91 bb 06 	lds	r27, 0x06BB	; 0x8006bb <pxCurrentTCB+0x1>
     6fa:	cd 91       	ld	r28, X+
     6fc:	cd bf       	out	0x3d, r28	; 61
     6fe:	dd 91       	ld	r29, X+
     700:	de bf       	out	0x3e, r29	; 62
     702:	ff 91       	pop	r31
     704:	ef 91       	pop	r30
     706:	df 91       	pop	r29
     708:	cf 91       	pop	r28
     70a:	bf 91       	pop	r27
     70c:	af 91       	pop	r26
     70e:	9f 91       	pop	r25
     710:	8f 91       	pop	r24
     712:	7f 91       	pop	r23
     714:	6f 91       	pop	r22
     716:	5f 91       	pop	r21
     718:	4f 91       	pop	r20
     71a:	3f 91       	pop	r19
     71c:	2f 91       	pop	r18
     71e:	1f 91       	pop	r17
     720:	0f 91       	pop	r16
     722:	ff 90       	pop	r15
     724:	ef 90       	pop	r14
     726:	df 90       	pop	r13
     728:	cf 90       	pop	r12
     72a:	bf 90       	pop	r11
     72c:	af 90       	pop	r10
     72e:	9f 90       	pop	r9
     730:	8f 90       	pop	r8
     732:	7f 90       	pop	r7
     734:	6f 90       	pop	r6
     736:	5f 90       	pop	r5
     738:	4f 90       	pop	r4
     73a:	3f 90       	pop	r3
     73c:	2f 90       	pop	r2
     73e:	1f 90       	pop	r1
     740:	0f 90       	pop	r0
     742:	0f be       	out	0x3f, r0	; 63
     744:	0f 90       	pop	r0
     746:	08 95       	ret
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	08 95       	ret

0000074c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     74c:	0f 92       	push	r0
     74e:	0f b6       	in	r0, 0x3f	; 63
     750:	f8 94       	cli
     752:	0f 92       	push	r0
     754:	1f 92       	push	r1
     756:	11 24       	eor	r1, r1
     758:	2f 92       	push	r2
     75a:	3f 92       	push	r3
     75c:	4f 92       	push	r4
     75e:	5f 92       	push	r5
     760:	6f 92       	push	r6
     762:	7f 92       	push	r7
     764:	8f 92       	push	r8
     766:	9f 92       	push	r9
     768:	af 92       	push	r10
     76a:	bf 92       	push	r11
     76c:	cf 92       	push	r12
     76e:	df 92       	push	r13
     770:	ef 92       	push	r14
     772:	ff 92       	push	r15
     774:	0f 93       	push	r16
     776:	1f 93       	push	r17
     778:	2f 93       	push	r18
     77a:	3f 93       	push	r19
     77c:	4f 93       	push	r20
     77e:	5f 93       	push	r21
     780:	6f 93       	push	r22
     782:	7f 93       	push	r23
     784:	8f 93       	push	r24
     786:	9f 93       	push	r25
     788:	af 93       	push	r26
     78a:	bf 93       	push	r27
     78c:	cf 93       	push	r28
     78e:	df 93       	push	r29
     790:	ef 93       	push	r30
     792:	ff 93       	push	r31
     794:	a0 91 ba 06 	lds	r26, 0x06BA	; 0x8006ba <pxCurrentTCB>
     798:	b0 91 bb 06 	lds	r27, 0x06BB	; 0x8006bb <pxCurrentTCB+0x1>
     79c:	0d b6       	in	r0, 0x3d	; 61
     79e:	0d 92       	st	X+, r0
     7a0:	0e b6       	in	r0, 0x3e	; 62
     7a2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     7a4:	0e 94 85 0a 	call	0x150a	; 0x150a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     7a8:	a0 91 ba 06 	lds	r26, 0x06BA	; 0x8006ba <pxCurrentTCB>
     7ac:	b0 91 bb 06 	lds	r27, 0x06BB	; 0x8006bb <pxCurrentTCB+0x1>
     7b0:	cd 91       	ld	r28, X+
     7b2:	cd bf       	out	0x3d, r28	; 61
     7b4:	dd 91       	ld	r29, X+
     7b6:	de bf       	out	0x3e, r29	; 62
     7b8:	ff 91       	pop	r31
     7ba:	ef 91       	pop	r30
     7bc:	df 91       	pop	r29
     7be:	cf 91       	pop	r28
     7c0:	bf 91       	pop	r27
     7c2:	af 91       	pop	r26
     7c4:	9f 91       	pop	r25
     7c6:	8f 91       	pop	r24
     7c8:	7f 91       	pop	r23
     7ca:	6f 91       	pop	r22
     7cc:	5f 91       	pop	r21
     7ce:	4f 91       	pop	r20
     7d0:	3f 91       	pop	r19
     7d2:	2f 91       	pop	r18
     7d4:	1f 91       	pop	r17
     7d6:	0f 91       	pop	r16
     7d8:	ff 90       	pop	r15
     7da:	ef 90       	pop	r14
     7dc:	df 90       	pop	r13
     7de:	cf 90       	pop	r12
     7e0:	bf 90       	pop	r11
     7e2:	af 90       	pop	r10
     7e4:	9f 90       	pop	r9
     7e6:	8f 90       	pop	r8
     7e8:	7f 90       	pop	r7
     7ea:	6f 90       	pop	r6
     7ec:	5f 90       	pop	r5
     7ee:	4f 90       	pop	r4
     7f0:	3f 90       	pop	r3
     7f2:	2f 90       	pop	r2
     7f4:	1f 90       	pop	r1
     7f6:	0f 90       	pop	r0
     7f8:	0f be       	out	0x3f, r0	; 63
     7fa:	0f 90       	pop	r0

	asm volatile ( "ret" );
     7fc:	08 95       	ret

000007fe <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     7fe:	0f 92       	push	r0
     800:	0f b6       	in	r0, 0x3f	; 63
     802:	f8 94       	cli
     804:	0f 92       	push	r0
     806:	1f 92       	push	r1
     808:	11 24       	eor	r1, r1
     80a:	2f 92       	push	r2
     80c:	3f 92       	push	r3
     80e:	4f 92       	push	r4
     810:	5f 92       	push	r5
     812:	6f 92       	push	r6
     814:	7f 92       	push	r7
     816:	8f 92       	push	r8
     818:	9f 92       	push	r9
     81a:	af 92       	push	r10
     81c:	bf 92       	push	r11
     81e:	cf 92       	push	r12
     820:	df 92       	push	r13
     822:	ef 92       	push	r14
     824:	ff 92       	push	r15
     826:	0f 93       	push	r16
     828:	1f 93       	push	r17
     82a:	2f 93       	push	r18
     82c:	3f 93       	push	r19
     82e:	4f 93       	push	r20
     830:	5f 93       	push	r21
     832:	6f 93       	push	r22
     834:	7f 93       	push	r23
     836:	8f 93       	push	r24
     838:	9f 93       	push	r25
     83a:	af 93       	push	r26
     83c:	bf 93       	push	r27
     83e:	cf 93       	push	r28
     840:	df 93       	push	r29
     842:	ef 93       	push	r30
     844:	ff 93       	push	r31
     846:	a0 91 ba 06 	lds	r26, 0x06BA	; 0x8006ba <pxCurrentTCB>
     84a:	b0 91 bb 06 	lds	r27, 0x06BB	; 0x8006bb <pxCurrentTCB+0x1>
     84e:	0d b6       	in	r0, 0x3d	; 61
     850:	0d 92       	st	X+, r0
     852:	0e b6       	in	r0, 0x3e	; 62
     854:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     856:	0e 94 37 09 	call	0x126e	; 0x126e <xTaskIncrementTick>
     85a:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     85c:	0e 94 85 0a 	call	0x150a	; 0x150a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     860:	a0 91 ba 06 	lds	r26, 0x06BA	; 0x8006ba <pxCurrentTCB>
     864:	b0 91 bb 06 	lds	r27, 0x06BB	; 0x8006bb <pxCurrentTCB+0x1>
     868:	cd 91       	ld	r28, X+
     86a:	cd bf       	out	0x3d, r28	; 61
     86c:	dd 91       	ld	r29, X+
     86e:	de bf       	out	0x3e, r29	; 62
     870:	ff 91       	pop	r31
     872:	ef 91       	pop	r30
     874:	df 91       	pop	r29
     876:	cf 91       	pop	r28
     878:	bf 91       	pop	r27
     87a:	af 91       	pop	r26
     87c:	9f 91       	pop	r25
     87e:	8f 91       	pop	r24
     880:	7f 91       	pop	r23
     882:	6f 91       	pop	r22
     884:	5f 91       	pop	r21
     886:	4f 91       	pop	r20
     888:	3f 91       	pop	r19
     88a:	2f 91       	pop	r18
     88c:	1f 91       	pop	r17
     88e:	0f 91       	pop	r16
     890:	ff 90       	pop	r15
     892:	ef 90       	pop	r14
     894:	df 90       	pop	r13
     896:	cf 90       	pop	r12
     898:	bf 90       	pop	r11
     89a:	af 90       	pop	r10
     89c:	9f 90       	pop	r9
     89e:	8f 90       	pop	r8
     8a0:	7f 90       	pop	r7
     8a2:	6f 90       	pop	r6
     8a4:	5f 90       	pop	r5
     8a6:	4f 90       	pop	r4
     8a8:	3f 90       	pop	r3
     8aa:	2f 90       	pop	r2
     8ac:	1f 90       	pop	r1
     8ae:	0f 90       	pop	r0
     8b0:	0f be       	out	0x3f, r0	; 63
     8b2:	0f 90       	pop	r0

	asm volatile ( "ret" );
     8b4:	08 95       	ret

000008b6 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     8b6:	0e 94 ff 03 	call	0x7fe	; 0x7fe <vPortYieldFromTick>
		asm volatile ( "reti" );
     8ba:	18 95       	reti

000008bc <prvIsQueueEmpty>:
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
     8bc:	0f b6       	in	r0, 0x3f	; 63
     8be:	f8 94       	cli
     8c0:	0f 92       	push	r0
     8c2:	fc 01       	movw	r30, r24
     8c4:	92 8d       	ldd	r25, Z+26	; 0x1a
     8c6:	0f 90       	pop	r0
     8c8:	0f be       	out	0x3f, r0	; 63
     8ca:	81 e0       	ldi	r24, 0x01	; 1
     8cc:	91 11       	cpse	r25, r1
     8ce:	80 e0       	ldi	r24, 0x00	; 0
     8d0:	08 95       	ret

000008d2 <prvCopyDataToQueue>:
     8d2:	0f 93       	push	r16
     8d4:	1f 93       	push	r17
     8d6:	cf 93       	push	r28
     8d8:	df 93       	push	r29
     8da:	ec 01       	movw	r28, r24
     8dc:	04 2f       	mov	r16, r20
     8de:	1a 8d       	ldd	r17, Y+26	; 0x1a
     8e0:	4c 8d       	ldd	r20, Y+28	; 0x1c
     8e2:	44 23       	and	r20, r20
     8e4:	b9 f1       	breq	.+110    	; 0x954 <prvCopyDataToQueue+0x82>
     8e6:	01 11       	cpse	r16, r1
     8e8:	16 c0       	rjmp	.+44     	; 0x916 <prvCopyDataToQueue+0x44>
     8ea:	50 e0       	ldi	r21, 0x00	; 0
     8ec:	8a 81       	ldd	r24, Y+2	; 0x02
     8ee:	9b 81       	ldd	r25, Y+3	; 0x03
     8f0:	0e 94 a1 0b 	call	0x1742	; 0x1742 <memcpy>
     8f4:	2c 8d       	ldd	r18, Y+28	; 0x1c
     8f6:	8a 81       	ldd	r24, Y+2	; 0x02
     8f8:	9b 81       	ldd	r25, Y+3	; 0x03
     8fa:	82 0f       	add	r24, r18
     8fc:	91 1d       	adc	r25, r1
     8fe:	9b 83       	std	Y+3, r25	; 0x03
     900:	8a 83       	std	Y+2, r24	; 0x02
     902:	2c 81       	ldd	r18, Y+4	; 0x04
     904:	3d 81       	ldd	r19, Y+5	; 0x05
     906:	82 17       	cp	r24, r18
     908:	93 07       	cpc	r25, r19
     90a:	20 f1       	brcs	.+72     	; 0x954 <prvCopyDataToQueue+0x82>
     90c:	88 81       	ld	r24, Y
     90e:	99 81       	ldd	r25, Y+1	; 0x01
     910:	9b 83       	std	Y+3, r25	; 0x03
     912:	8a 83       	std	Y+2, r24	; 0x02
     914:	1f c0       	rjmp	.+62     	; 0x954 <prvCopyDataToQueue+0x82>
     916:	50 e0       	ldi	r21, 0x00	; 0
     918:	8e 81       	ldd	r24, Y+6	; 0x06
     91a:	9f 81       	ldd	r25, Y+7	; 0x07
     91c:	0e 94 a1 0b 	call	0x1742	; 0x1742 <memcpy>
     920:	8c 8d       	ldd	r24, Y+28	; 0x1c
     922:	90 e0       	ldi	r25, 0x00	; 0
     924:	91 95       	neg	r25
     926:	81 95       	neg	r24
     928:	91 09       	sbc	r25, r1
     92a:	2e 81       	ldd	r18, Y+6	; 0x06
     92c:	3f 81       	ldd	r19, Y+7	; 0x07
     92e:	28 0f       	add	r18, r24
     930:	39 1f       	adc	r19, r25
     932:	3f 83       	std	Y+7, r19	; 0x07
     934:	2e 83       	std	Y+6, r18	; 0x06
     936:	48 81       	ld	r20, Y
     938:	59 81       	ldd	r21, Y+1	; 0x01
     93a:	24 17       	cp	r18, r20
     93c:	35 07       	cpc	r19, r21
     93e:	30 f4       	brcc	.+12     	; 0x94c <prvCopyDataToQueue+0x7a>
     940:	2c 81       	ldd	r18, Y+4	; 0x04
     942:	3d 81       	ldd	r19, Y+5	; 0x05
     944:	82 0f       	add	r24, r18
     946:	93 1f       	adc	r25, r19
     948:	9f 83       	std	Y+7, r25	; 0x07
     94a:	8e 83       	std	Y+6, r24	; 0x06
     94c:	02 30       	cpi	r16, 0x02	; 2
     94e:	11 f4       	brne	.+4      	; 0x954 <prvCopyDataToQueue+0x82>
     950:	11 11       	cpse	r17, r1
     952:	11 50       	subi	r17, 0x01	; 1
     954:	1f 5f       	subi	r17, 0xFF	; 255
     956:	1a 8f       	std	Y+26, r17	; 0x1a
     958:	80 e0       	ldi	r24, 0x00	; 0
     95a:	df 91       	pop	r29
     95c:	cf 91       	pop	r28
     95e:	1f 91       	pop	r17
     960:	0f 91       	pop	r16
     962:	08 95       	ret

00000964 <prvCopyDataFromQueue>:
     964:	fc 01       	movw	r30, r24
     966:	44 8d       	ldd	r20, Z+28	; 0x1c
     968:	44 23       	and	r20, r20
     96a:	a9 f0       	breq	.+42     	; 0x996 <prvCopyDataFromQueue+0x32>
     96c:	50 e0       	ldi	r21, 0x00	; 0
     96e:	26 81       	ldd	r18, Z+6	; 0x06
     970:	37 81       	ldd	r19, Z+7	; 0x07
     972:	24 0f       	add	r18, r20
     974:	35 1f       	adc	r19, r21
     976:	37 83       	std	Z+7, r19	; 0x07
     978:	26 83       	std	Z+6, r18	; 0x06
     97a:	84 81       	ldd	r24, Z+4	; 0x04
     97c:	95 81       	ldd	r25, Z+5	; 0x05
     97e:	28 17       	cp	r18, r24
     980:	39 07       	cpc	r19, r25
     982:	20 f0       	brcs	.+8      	; 0x98c <prvCopyDataFromQueue+0x28>
     984:	80 81       	ld	r24, Z
     986:	91 81       	ldd	r25, Z+1	; 0x01
     988:	97 83       	std	Z+7, r25	; 0x07
     98a:	86 83       	std	Z+6, r24	; 0x06
     98c:	cb 01       	movw	r24, r22
     98e:	66 81       	ldd	r22, Z+6	; 0x06
     990:	77 81       	ldd	r23, Z+7	; 0x07
     992:	0e 94 a1 0b 	call	0x1742	; 0x1742 <memcpy>
     996:	08 95       	ret

00000998 <prvUnlockQueue>:
     998:	ef 92       	push	r14
     99a:	ff 92       	push	r15
     99c:	0f 93       	push	r16
     99e:	1f 93       	push	r17
     9a0:	cf 93       	push	r28
     9a2:	8c 01       	movw	r16, r24
     9a4:	0f b6       	in	r0, 0x3f	; 63
     9a6:	f8 94       	cli
     9a8:	0f 92       	push	r0
     9aa:	fc 01       	movw	r30, r24
     9ac:	c6 8d       	ldd	r28, Z+30	; 0x1e
     9ae:	1c 16       	cp	r1, r28
     9b0:	ac f4       	brge	.+42     	; 0x9dc <prvUnlockQueue+0x44>
     9b2:	81 89       	ldd	r24, Z+17	; 0x11
     9b4:	81 11       	cpse	r24, r1
     9b6:	06 c0       	rjmp	.+12     	; 0x9c4 <prvUnlockQueue+0x2c>
     9b8:	11 c0       	rjmp	.+34     	; 0x9dc <prvUnlockQueue+0x44>
     9ba:	f8 01       	movw	r30, r16
     9bc:	81 89       	ldd	r24, Z+17	; 0x11
     9be:	81 11       	cpse	r24, r1
     9c0:	05 c0       	rjmp	.+10     	; 0x9cc <prvUnlockQueue+0x34>
     9c2:	0c c0       	rjmp	.+24     	; 0x9dc <prvUnlockQueue+0x44>
     9c4:	78 01       	movw	r14, r16
     9c6:	f1 e1       	ldi	r31, 0x11	; 17
     9c8:	ef 0e       	add	r14, r31
     9ca:	f1 1c       	adc	r15, r1
     9cc:	c7 01       	movw	r24, r14
     9ce:	0e 94 fd 0a 	call	0x15fa	; 0x15fa <xTaskRemoveFromEventList>
     9d2:	81 11       	cpse	r24, r1
     9d4:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <vTaskMissedYield>
     9d8:	c1 50       	subi	r28, 0x01	; 1
     9da:	79 f7       	brne	.-34     	; 0x9ba <prvUnlockQueue+0x22>
     9dc:	8f ef       	ldi	r24, 0xFF	; 255
     9de:	f8 01       	movw	r30, r16
     9e0:	86 8f       	std	Z+30, r24	; 0x1e
     9e2:	0f 90       	pop	r0
     9e4:	0f be       	out	0x3f, r0	; 63
     9e6:	0f b6       	in	r0, 0x3f	; 63
     9e8:	f8 94       	cli
     9ea:	0f 92       	push	r0
     9ec:	c5 8d       	ldd	r28, Z+29	; 0x1d
     9ee:	1c 16       	cp	r1, r28
     9f0:	ac f4       	brge	.+42     	; 0xa1c <prvUnlockQueue+0x84>
     9f2:	80 85       	ldd	r24, Z+8	; 0x08
     9f4:	81 11       	cpse	r24, r1
     9f6:	06 c0       	rjmp	.+12     	; 0xa04 <prvUnlockQueue+0x6c>
     9f8:	11 c0       	rjmp	.+34     	; 0xa1c <prvUnlockQueue+0x84>
     9fa:	f8 01       	movw	r30, r16
     9fc:	80 85       	ldd	r24, Z+8	; 0x08
     9fe:	81 11       	cpse	r24, r1
     a00:	05 c0       	rjmp	.+10     	; 0xa0c <prvUnlockQueue+0x74>
     a02:	0c c0       	rjmp	.+24     	; 0xa1c <prvUnlockQueue+0x84>
     a04:	78 01       	movw	r14, r16
     a06:	f8 e0       	ldi	r31, 0x08	; 8
     a08:	ef 0e       	add	r14, r31
     a0a:	f1 1c       	adc	r15, r1
     a0c:	c7 01       	movw	r24, r14
     a0e:	0e 94 fd 0a 	call	0x15fa	; 0x15fa <xTaskRemoveFromEventList>
     a12:	81 11       	cpse	r24, r1
     a14:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <vTaskMissedYield>
     a18:	c1 50       	subi	r28, 0x01	; 1
     a1a:	79 f7       	brne	.-34     	; 0x9fa <prvUnlockQueue+0x62>
     a1c:	8f ef       	ldi	r24, 0xFF	; 255
     a1e:	f8 01       	movw	r30, r16
     a20:	85 8f       	std	Z+29, r24	; 0x1d
     a22:	0f 90       	pop	r0
     a24:	0f be       	out	0x3f, r0	; 63
     a26:	cf 91       	pop	r28
     a28:	1f 91       	pop	r17
     a2a:	0f 91       	pop	r16
     a2c:	ff 90       	pop	r15
     a2e:	ef 90       	pop	r14
     a30:	08 95       	ret

00000a32 <xQueueGenericReset>:
     a32:	cf 93       	push	r28
     a34:	df 93       	push	r29
     a36:	ec 01       	movw	r28, r24
     a38:	0f b6       	in	r0, 0x3f	; 63
     a3a:	f8 94       	cli
     a3c:	0f 92       	push	r0
     a3e:	e8 81       	ld	r30, Y
     a40:	f9 81       	ldd	r31, Y+1	; 0x01
     a42:	8b 8d       	ldd	r24, Y+27	; 0x1b
     a44:	2c 8d       	ldd	r18, Y+28	; 0x1c
     a46:	90 e0       	ldi	r25, 0x00	; 0
     a48:	30 e0       	ldi	r19, 0x00	; 0
     a4a:	82 9f       	mul	r24, r18
     a4c:	a0 01       	movw	r20, r0
     a4e:	83 9f       	mul	r24, r19
     a50:	50 0d       	add	r21, r0
     a52:	92 9f       	mul	r25, r18
     a54:	50 0d       	add	r21, r0
     a56:	11 24       	eor	r1, r1
     a58:	4e 0f       	add	r20, r30
     a5a:	5f 1f       	adc	r21, r31
     a5c:	5d 83       	std	Y+5, r21	; 0x05
     a5e:	4c 83       	std	Y+4, r20	; 0x04
     a60:	1a 8e       	std	Y+26, r1	; 0x1a
     a62:	fb 83       	std	Y+3, r31	; 0x03
     a64:	ea 83       	std	Y+2, r30	; 0x02
     a66:	01 97       	sbiw	r24, 0x01	; 1
     a68:	82 9f       	mul	r24, r18
     a6a:	a0 01       	movw	r20, r0
     a6c:	83 9f       	mul	r24, r19
     a6e:	50 0d       	add	r21, r0
     a70:	92 9f       	mul	r25, r18
     a72:	50 0d       	add	r21, r0
     a74:	11 24       	eor	r1, r1
     a76:	cf 01       	movw	r24, r30
     a78:	84 0f       	add	r24, r20
     a7a:	95 1f       	adc	r25, r21
     a7c:	9f 83       	std	Y+7, r25	; 0x07
     a7e:	8e 83       	std	Y+6, r24	; 0x06
     a80:	8f ef       	ldi	r24, 0xFF	; 255
     a82:	8d 8f       	std	Y+29, r24	; 0x1d
     a84:	8e 8f       	std	Y+30, r24	; 0x1e
     a86:	61 11       	cpse	r22, r1
     a88:	0c c0       	rjmp	.+24     	; 0xaa2 <xQueueGenericReset+0x70>
     a8a:	88 85       	ldd	r24, Y+8	; 0x08
     a8c:	88 23       	and	r24, r24
     a8e:	89 f0       	breq	.+34     	; 0xab2 <xQueueGenericReset+0x80>
     a90:	ce 01       	movw	r24, r28
     a92:	08 96       	adiw	r24, 0x08	; 8
     a94:	0e 94 fd 0a 	call	0x15fa	; 0x15fa <xTaskRemoveFromEventList>
     a98:	88 23       	and	r24, r24
     a9a:	59 f0       	breq	.+22     	; 0xab2 <xQueueGenericReset+0x80>
     a9c:	0e 94 a6 03 	call	0x74c	; 0x74c <vPortYield>
     aa0:	08 c0       	rjmp	.+16     	; 0xab2 <xQueueGenericReset+0x80>
     aa2:	ce 01       	movw	r24, r28
     aa4:	08 96       	adiw	r24, 0x08	; 8
     aa6:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <vListInitialise>
     aaa:	ce 01       	movw	r24, r28
     aac:	41 96       	adiw	r24, 0x11	; 17
     aae:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <vListInitialise>
     ab2:	0f 90       	pop	r0
     ab4:	0f be       	out	0x3f, r0	; 63
     ab6:	81 e0       	ldi	r24, 0x01	; 1
     ab8:	df 91       	pop	r29
     aba:	cf 91       	pop	r28
     abc:	08 95       	ret

00000abe <xQueueGenericCreate>:
     abe:	0f 93       	push	r16
     ac0:	1f 93       	push	r17
     ac2:	cf 93       	push	r28
     ac4:	df 93       	push	r29
     ac6:	08 2f       	mov	r16, r24
     ac8:	16 2f       	mov	r17, r22
     aca:	66 23       	and	r22, r22
     acc:	c1 f0       	breq	.+48     	; 0xafe <xQueueGenericCreate+0x40>
     ace:	86 9f       	mul	r24, r22
     ad0:	c0 01       	movw	r24, r0
     ad2:	11 24       	eor	r1, r1
     ad4:	4f 96       	adiw	r24, 0x1f	; 31
     ad6:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     ada:	ec 01       	movw	r28, r24
     adc:	00 97       	sbiw	r24, 0x00	; 0
     ade:	41 f4       	brne	.+16     	; 0xaf0 <xQueueGenericCreate+0x32>
     ae0:	15 c0       	rjmp	.+42     	; 0xb0c <xQueueGenericCreate+0x4e>
     ae2:	0b 8f       	std	Y+27, r16	; 0x1b
     ae4:	1c 8f       	std	Y+28, r17	; 0x1c
     ae6:	61 e0       	ldi	r22, 0x01	; 1
     ae8:	ce 01       	movw	r24, r28
     aea:	0e 94 19 05 	call	0xa32	; 0xa32 <xQueueGenericReset>
     aee:	0e c0       	rjmp	.+28     	; 0xb0c <xQueueGenericCreate+0x4e>
     af0:	4f 96       	adiw	r24, 0x1f	; 31
     af2:	99 83       	std	Y+1, r25	; 0x01
     af4:	88 83       	st	Y, r24
     af6:	f5 cf       	rjmp	.-22     	; 0xae2 <xQueueGenericCreate+0x24>
     af8:	d9 83       	std	Y+1, r29	; 0x01
     afa:	c8 83       	st	Y, r28
     afc:	f2 cf       	rjmp	.-28     	; 0xae2 <xQueueGenericCreate+0x24>
     afe:	8f e1       	ldi	r24, 0x1F	; 31
     b00:	90 e0       	ldi	r25, 0x00	; 0
     b02:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
     b06:	ec 01       	movw	r28, r24
     b08:	89 2b       	or	r24, r25
     b0a:	b1 f7       	brne	.-20     	; 0xaf8 <xQueueGenericCreate+0x3a>
     b0c:	ce 01       	movw	r24, r28
     b0e:	df 91       	pop	r29
     b10:	cf 91       	pop	r28
     b12:	1f 91       	pop	r17
     b14:	0f 91       	pop	r16
     b16:	08 95       	ret

00000b18 <xQueueGenericSend>:
     b18:	9f 92       	push	r9
     b1a:	af 92       	push	r10
     b1c:	bf 92       	push	r11
     b1e:	cf 92       	push	r12
     b20:	df 92       	push	r13
     b22:	ef 92       	push	r14
     b24:	ff 92       	push	r15
     b26:	0f 93       	push	r16
     b28:	1f 93       	push	r17
     b2a:	cf 93       	push	r28
     b2c:	df 93       	push	r29
     b2e:	00 d0       	rcall	.+0      	; 0xb30 <xQueueGenericSend+0x18>
     b30:	00 d0       	rcall	.+0      	; 0xb32 <xQueueGenericSend+0x1a>
     b32:	1f 92       	push	r1
     b34:	cd b7       	in	r28, 0x3d	; 61
     b36:	de b7       	in	r29, 0x3e	; 62
     b38:	8c 01       	movw	r16, r24
     b3a:	6b 01       	movw	r12, r22
     b3c:	5d 83       	std	Y+5, r21	; 0x05
     b3e:	4c 83       	std	Y+4, r20	; 0x04
     b40:	a2 2e       	mov	r10, r18
     b42:	b1 2c       	mov	r11, r1
     b44:	99 24       	eor	r9, r9
     b46:	93 94       	inc	r9
     b48:	7c 01       	movw	r14, r24
     b4a:	88 e0       	ldi	r24, 0x08	; 8
     b4c:	e8 0e       	add	r14, r24
     b4e:	f1 1c       	adc	r15, r1
     b50:	0f b6       	in	r0, 0x3f	; 63
     b52:	f8 94       	cli
     b54:	0f 92       	push	r0
     b56:	f8 01       	movw	r30, r16
     b58:	92 8d       	ldd	r25, Z+26	; 0x1a
     b5a:	83 8d       	ldd	r24, Z+27	; 0x1b
     b5c:	98 17       	cp	r25, r24
     b5e:	18 f0       	brcs	.+6      	; 0xb66 <xQueueGenericSend+0x4e>
     b60:	f2 e0       	ldi	r31, 0x02	; 2
     b62:	af 12       	cpse	r10, r31
     b64:	19 c0       	rjmp	.+50     	; 0xb98 <xQueueGenericSend+0x80>
     b66:	4a 2d       	mov	r20, r10
     b68:	b6 01       	movw	r22, r12
     b6a:	c8 01       	movw	r24, r16
     b6c:	0e 94 69 04 	call	0x8d2	; 0x8d2 <prvCopyDataToQueue>
     b70:	f8 01       	movw	r30, r16
     b72:	91 89       	ldd	r25, Z+17	; 0x11
     b74:	99 23       	and	r25, r25
     b76:	49 f0       	breq	.+18     	; 0xb8a <xQueueGenericSend+0x72>
     b78:	c8 01       	movw	r24, r16
     b7a:	41 96       	adiw	r24, 0x11	; 17
     b7c:	0e 94 fd 0a 	call	0x15fa	; 0x15fa <xTaskRemoveFromEventList>
     b80:	88 23       	and	r24, r24
     b82:	31 f0       	breq	.+12     	; 0xb90 <xQueueGenericSend+0x78>
     b84:	0e 94 a6 03 	call	0x74c	; 0x74c <vPortYield>
     b88:	03 c0       	rjmp	.+6      	; 0xb90 <xQueueGenericSend+0x78>
     b8a:	81 11       	cpse	r24, r1
     b8c:	0e 94 a6 03 	call	0x74c	; 0x74c <vPortYield>
     b90:	0f 90       	pop	r0
     b92:	0f be       	out	0x3f, r0	; 63
     b94:	81 e0       	ldi	r24, 0x01	; 1
     b96:	50 c0       	rjmp	.+160    	; 0xc38 <xQueueGenericSend+0x120>
     b98:	8c 81       	ldd	r24, Y+4	; 0x04
     b9a:	9d 81       	ldd	r25, Y+5	; 0x05
     b9c:	89 2b       	or	r24, r25
     b9e:	21 f4       	brne	.+8      	; 0xba8 <xQueueGenericSend+0x90>
     ba0:	0f 90       	pop	r0
     ba2:	0f be       	out	0x3f, r0	; 63
     ba4:	80 e0       	ldi	r24, 0x00	; 0
     ba6:	48 c0       	rjmp	.+144    	; 0xc38 <xQueueGenericSend+0x120>
     ba8:	b1 10       	cpse	r11, r1
     baa:	05 c0       	rjmp	.+10     	; 0xbb6 <xQueueGenericSend+0x9e>
     bac:	ce 01       	movw	r24, r28
     bae:	01 96       	adiw	r24, 0x01	; 1
     bb0:	0e 94 45 0b 	call	0x168a	; 0x168a <vTaskInternalSetTimeOutState>
     bb4:	b9 2c       	mov	r11, r9
     bb6:	0f 90       	pop	r0
     bb8:	0f be       	out	0x3f, r0	; 63
     bba:	0e 94 31 09 	call	0x1262	; 0x1262 <vTaskSuspendAll>
     bbe:	0f b6       	in	r0, 0x3f	; 63
     bc0:	f8 94       	cli
     bc2:	0f 92       	push	r0
     bc4:	f8 01       	movw	r30, r16
     bc6:	85 8d       	ldd	r24, Z+29	; 0x1d
     bc8:	8f 3f       	cpi	r24, 0xFF	; 255
     bca:	09 f4       	brne	.+2      	; 0xbce <xQueueGenericSend+0xb6>
     bcc:	15 8e       	std	Z+29, r1	; 0x1d
     bce:	f8 01       	movw	r30, r16
     bd0:	86 8d       	ldd	r24, Z+30	; 0x1e
     bd2:	8f 3f       	cpi	r24, 0xFF	; 255
     bd4:	09 f4       	brne	.+2      	; 0xbd8 <xQueueGenericSend+0xc0>
     bd6:	16 8e       	std	Z+30, r1	; 0x1e
     bd8:	0f 90       	pop	r0
     bda:	0f be       	out	0x3f, r0	; 63
     bdc:	be 01       	movw	r22, r28
     bde:	6c 5f       	subi	r22, 0xFC	; 252
     be0:	7f 4f       	sbci	r23, 0xFF	; 255
     be2:	ce 01       	movw	r24, r28
     be4:	01 96       	adiw	r24, 0x01	; 1
     be6:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <xTaskCheckForTimeOut>
     bea:	81 11       	cpse	r24, r1
     bec:	1f c0       	rjmp	.+62     	; 0xc2c <xQueueGenericSend+0x114>
     bee:	0f b6       	in	r0, 0x3f	; 63
     bf0:	f8 94       	cli
     bf2:	0f 92       	push	r0
     bf4:	f8 01       	movw	r30, r16
     bf6:	92 8d       	ldd	r25, Z+26	; 0x1a
     bf8:	0f 90       	pop	r0
     bfa:	0f be       	out	0x3f, r0	; 63
     bfc:	83 8d       	ldd	r24, Z+27	; 0x1b
     bfe:	98 13       	cpse	r25, r24
     c00:	0f c0       	rjmp	.+30     	; 0xc20 <xQueueGenericSend+0x108>
     c02:	6c 81       	ldd	r22, Y+4	; 0x04
     c04:	7d 81       	ldd	r23, Y+5	; 0x05
     c06:	c7 01       	movw	r24, r14
     c08:	0e 94 eb 0a 	call	0x15d6	; 0x15d6 <vTaskPlaceOnEventList>
     c0c:	c8 01       	movw	r24, r16
     c0e:	0e 94 cc 04 	call	0x998	; 0x998 <prvUnlockQueue>
     c12:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <xTaskResumeAll>
     c16:	81 11       	cpse	r24, r1
     c18:	9b cf       	rjmp	.-202    	; 0xb50 <xQueueGenericSend+0x38>
     c1a:	0e 94 a6 03 	call	0x74c	; 0x74c <vPortYield>
     c1e:	98 cf       	rjmp	.-208    	; 0xb50 <xQueueGenericSend+0x38>
     c20:	c8 01       	movw	r24, r16
     c22:	0e 94 cc 04 	call	0x998	; 0x998 <prvUnlockQueue>
     c26:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <xTaskResumeAll>
     c2a:	92 cf       	rjmp	.-220    	; 0xb50 <xQueueGenericSend+0x38>
     c2c:	c8 01       	movw	r24, r16
     c2e:	0e 94 cc 04 	call	0x998	; 0x998 <prvUnlockQueue>
     c32:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <xTaskResumeAll>
     c36:	80 e0       	ldi	r24, 0x00	; 0
     c38:	0f 90       	pop	r0
     c3a:	0f 90       	pop	r0
     c3c:	0f 90       	pop	r0
     c3e:	0f 90       	pop	r0
     c40:	0f 90       	pop	r0
     c42:	df 91       	pop	r29
     c44:	cf 91       	pop	r28
     c46:	1f 91       	pop	r17
     c48:	0f 91       	pop	r16
     c4a:	ff 90       	pop	r15
     c4c:	ef 90       	pop	r14
     c4e:	df 90       	pop	r13
     c50:	cf 90       	pop	r12
     c52:	bf 90       	pop	r11
     c54:	af 90       	pop	r10
     c56:	9f 90       	pop	r9
     c58:	08 95       	ret

00000c5a <xQueueReceive>:
     c5a:	9f 92       	push	r9
     c5c:	af 92       	push	r10
     c5e:	bf 92       	push	r11
     c60:	cf 92       	push	r12
     c62:	df 92       	push	r13
     c64:	ef 92       	push	r14
     c66:	ff 92       	push	r15
     c68:	0f 93       	push	r16
     c6a:	1f 93       	push	r17
     c6c:	cf 93       	push	r28
     c6e:	df 93       	push	r29
     c70:	00 d0       	rcall	.+0      	; 0xc72 <xQueueReceive+0x18>
     c72:	00 d0       	rcall	.+0      	; 0xc74 <xQueueReceive+0x1a>
     c74:	1f 92       	push	r1
     c76:	cd b7       	in	r28, 0x3d	; 61
     c78:	de b7       	in	r29, 0x3e	; 62
     c7a:	8c 01       	movw	r16, r24
     c7c:	5b 01       	movw	r10, r22
     c7e:	5d 83       	std	Y+5, r21	; 0x05
     c80:	4c 83       	std	Y+4, r20	; 0x04
     c82:	e1 2c       	mov	r14, r1
     c84:	99 24       	eor	r9, r9
     c86:	93 94       	inc	r9
     c88:	6c 01       	movw	r12, r24
     c8a:	81 e1       	ldi	r24, 0x11	; 17
     c8c:	c8 0e       	add	r12, r24
     c8e:	d1 1c       	adc	r13, r1
     c90:	0f b6       	in	r0, 0x3f	; 63
     c92:	f8 94       	cli
     c94:	0f 92       	push	r0
     c96:	f8 01       	movw	r30, r16
     c98:	f2 8c       	ldd	r15, Z+26	; 0x1a
     c9a:	ff 20       	and	r15, r15
     c9c:	a9 f0       	breq	.+42     	; 0xcc8 <xQueueReceive+0x6e>
     c9e:	b5 01       	movw	r22, r10
     ca0:	c8 01       	movw	r24, r16
     ca2:	0e 94 b2 04 	call	0x964	; 0x964 <prvCopyDataFromQueue>
     ca6:	fa 94       	dec	r15
     ca8:	f8 01       	movw	r30, r16
     caa:	f2 8e       	std	Z+26, r15	; 0x1a
     cac:	80 85       	ldd	r24, Z+8	; 0x08
     cae:	88 23       	and	r24, r24
     cb0:	39 f0       	breq	.+14     	; 0xcc0 <xQueueReceive+0x66>
     cb2:	c8 01       	movw	r24, r16
     cb4:	08 96       	adiw	r24, 0x08	; 8
     cb6:	0e 94 fd 0a 	call	0x15fa	; 0x15fa <xTaskRemoveFromEventList>
     cba:	81 11       	cpse	r24, r1
     cbc:	0e 94 a6 03 	call	0x74c	; 0x74c <vPortYield>
     cc0:	0f 90       	pop	r0
     cc2:	0f be       	out	0x3f, r0	; 63
     cc4:	81 e0       	ldi	r24, 0x01	; 1
     cc6:	51 c0       	rjmp	.+162    	; 0xd6a <xQueueReceive+0x110>
     cc8:	8c 81       	ldd	r24, Y+4	; 0x04
     cca:	9d 81       	ldd	r25, Y+5	; 0x05
     ccc:	89 2b       	or	r24, r25
     cce:	21 f4       	brne	.+8      	; 0xcd8 <xQueueReceive+0x7e>
     cd0:	0f 90       	pop	r0
     cd2:	0f be       	out	0x3f, r0	; 63
     cd4:	80 e0       	ldi	r24, 0x00	; 0
     cd6:	49 c0       	rjmp	.+146    	; 0xd6a <xQueueReceive+0x110>
     cd8:	e1 10       	cpse	r14, r1
     cda:	05 c0       	rjmp	.+10     	; 0xce6 <xQueueReceive+0x8c>
     cdc:	ce 01       	movw	r24, r28
     cde:	01 96       	adiw	r24, 0x01	; 1
     ce0:	0e 94 45 0b 	call	0x168a	; 0x168a <vTaskInternalSetTimeOutState>
     ce4:	e9 2c       	mov	r14, r9
     ce6:	0f 90       	pop	r0
     ce8:	0f be       	out	0x3f, r0	; 63
     cea:	0e 94 31 09 	call	0x1262	; 0x1262 <vTaskSuspendAll>
     cee:	0f b6       	in	r0, 0x3f	; 63
     cf0:	f8 94       	cli
     cf2:	0f 92       	push	r0
     cf4:	f8 01       	movw	r30, r16
     cf6:	85 8d       	ldd	r24, Z+29	; 0x1d
     cf8:	8f 3f       	cpi	r24, 0xFF	; 255
     cfa:	09 f4       	brne	.+2      	; 0xcfe <xQueueReceive+0xa4>
     cfc:	15 8e       	std	Z+29, r1	; 0x1d
     cfe:	f8 01       	movw	r30, r16
     d00:	86 8d       	ldd	r24, Z+30	; 0x1e
     d02:	8f 3f       	cpi	r24, 0xFF	; 255
     d04:	09 f4       	brne	.+2      	; 0xd08 <xQueueReceive+0xae>
     d06:	16 8e       	std	Z+30, r1	; 0x1e
     d08:	0f 90       	pop	r0
     d0a:	0f be       	out	0x3f, r0	; 63
     d0c:	be 01       	movw	r22, r28
     d0e:	6c 5f       	subi	r22, 0xFC	; 252
     d10:	7f 4f       	sbci	r23, 0xFF	; 255
     d12:	ce 01       	movw	r24, r28
     d14:	01 96       	adiw	r24, 0x01	; 1
     d16:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <xTaskCheckForTimeOut>
     d1a:	81 11       	cpse	r24, r1
     d1c:	1a c0       	rjmp	.+52     	; 0xd52 <xQueueReceive+0xf8>
     d1e:	c8 01       	movw	r24, r16
     d20:	0e 94 5e 04 	call	0x8bc	; 0x8bc <prvIsQueueEmpty>
     d24:	88 23       	and	r24, r24
     d26:	79 f0       	breq	.+30     	; 0xd46 <xQueueReceive+0xec>
     d28:	6c 81       	ldd	r22, Y+4	; 0x04
     d2a:	7d 81       	ldd	r23, Y+5	; 0x05
     d2c:	c6 01       	movw	r24, r12
     d2e:	0e 94 eb 0a 	call	0x15d6	; 0x15d6 <vTaskPlaceOnEventList>
     d32:	c8 01       	movw	r24, r16
     d34:	0e 94 cc 04 	call	0x998	; 0x998 <prvUnlockQueue>
     d38:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <xTaskResumeAll>
     d3c:	81 11       	cpse	r24, r1
     d3e:	a8 cf       	rjmp	.-176    	; 0xc90 <xQueueReceive+0x36>
     d40:	0e 94 a6 03 	call	0x74c	; 0x74c <vPortYield>
     d44:	a5 cf       	rjmp	.-182    	; 0xc90 <xQueueReceive+0x36>
     d46:	c8 01       	movw	r24, r16
     d48:	0e 94 cc 04 	call	0x998	; 0x998 <prvUnlockQueue>
     d4c:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <xTaskResumeAll>
     d50:	9f cf       	rjmp	.-194    	; 0xc90 <xQueueReceive+0x36>
     d52:	c8 01       	movw	r24, r16
     d54:	0e 94 cc 04 	call	0x998	; 0x998 <prvUnlockQueue>
     d58:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <xTaskResumeAll>
     d5c:	c8 01       	movw	r24, r16
     d5e:	0e 94 5e 04 	call	0x8bc	; 0x8bc <prvIsQueueEmpty>
     d62:	88 23       	and	r24, r24
     d64:	09 f4       	brne	.+2      	; 0xd68 <xQueueReceive+0x10e>
     d66:	94 cf       	rjmp	.-216    	; 0xc90 <xQueueReceive+0x36>
     d68:	80 e0       	ldi	r24, 0x00	; 0
     d6a:	0f 90       	pop	r0
     d6c:	0f 90       	pop	r0
     d6e:	0f 90       	pop	r0
     d70:	0f 90       	pop	r0
     d72:	0f 90       	pop	r0
     d74:	df 91       	pop	r29
     d76:	cf 91       	pop	r28
     d78:	1f 91       	pop	r17
     d7a:	0f 91       	pop	r16
     d7c:	ff 90       	pop	r15
     d7e:	ef 90       	pop	r14
     d80:	df 90       	pop	r13
     d82:	cf 90       	pop	r12
     d84:	bf 90       	pop	r11
     d86:	af 90       	pop	r10
     d88:	9f 90       	pop	r9
     d8a:	08 95       	ret

00000d8c <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
     d8c:	af 92       	push	r10
     d8e:	bf 92       	push	r11
     d90:	cf 92       	push	r12
     d92:	df 92       	push	r13
     d94:	ef 92       	push	r14
     d96:	ff 92       	push	r15
     d98:	0f 93       	push	r16
     d9a:	1f 93       	push	r17
     d9c:	cf 93       	push	r28
     d9e:	df 93       	push	r29
     da0:	00 d0       	rcall	.+0      	; 0xda2 <xQueuePeek+0x16>
     da2:	00 d0       	rcall	.+0      	; 0xda4 <xQueuePeek+0x18>
     da4:	1f 92       	push	r1
     da6:	cd b7       	in	r28, 0x3d	; 61
     da8:	de b7       	in	r29, 0x3e	; 62
     daa:	8c 01       	movw	r16, r24
     dac:	6b 01       	movw	r12, r22
     dae:	5d 83       	std	Y+5, r21	; 0x05
     db0:	4c 83       	std	Y+4, r20	; 0x04
BaseType_t xEntryTimeSet = pdFALSE;
     db2:	b1 2c       	mov	r11, r1
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     db4:	aa 24       	eor	r10, r10
     db6:	a3 94       	inc	r10
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     db8:	7c 01       	movw	r14, r24
     dba:	81 e1       	ldi	r24, 0x11	; 17
     dbc:	e8 0e       	add	r14, r24
     dbe:	f1 1c       	adc	r15, r1
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     dc0:	0f b6       	in	r0, 0x3f	; 63
     dc2:	f8 94       	cli
     dc4:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
     dc6:	f8 01       	movw	r30, r16
     dc8:	82 8d       	ldd	r24, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
     dca:	88 23       	and	r24, r24
     dcc:	b9 f0       	breq	.+46     	; 0xdfc <xQueuePeek+0x70>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
     dce:	e6 80       	ldd	r14, Z+6	; 0x06
     dd0:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     dd2:	b6 01       	movw	r22, r12
     dd4:	c8 01       	movw	r24, r16
     dd6:	0e 94 b2 04 	call	0x964	; 0x964 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
     dda:	f8 01       	movw	r30, r16
     ddc:	f7 82       	std	Z+7, r15	; 0x07
     dde:	e6 82       	std	Z+6, r14	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     de0:	81 89       	ldd	r24, Z+17	; 0x11
     de2:	88 23       	and	r24, r24
     de4:	39 f0       	breq	.+14     	; 0xdf4 <xQueuePeek+0x68>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     de6:	c8 01       	movw	r24, r16
     de8:	41 96       	adiw	r24, 0x11	; 17
     dea:	0e 94 fd 0a 	call	0x15fa	; 0x15fa <xTaskRemoveFromEventList>
     dee:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
     df0:	0e 94 a6 03 	call	0x74c	; 0x74c <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
     df4:	0f 90       	pop	r0
     df6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     df8:	81 e0       	ldi	r24, 0x01	; 1
     dfa:	51 c0       	rjmp	.+162    	; 0xe9e <xQueuePeek+0x112>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     dfc:	8c 81       	ldd	r24, Y+4	; 0x04
     dfe:	9d 81       	ldd	r25, Y+5	; 0x05
     e00:	89 2b       	or	r24, r25
     e02:	21 f4       	brne	.+8      	; 0xe0c <xQueuePeek+0x80>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     e04:	0f 90       	pop	r0
     e06:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     e08:	80 e0       	ldi	r24, 0x00	; 0
     e0a:	49 c0       	rjmp	.+146    	; 0xe9e <xQueuePeek+0x112>
				}
				else if( xEntryTimeSet == pdFALSE )
     e0c:	b1 10       	cpse	r11, r1
     e0e:	05 c0       	rjmp	.+10     	; 0xe1a <xQueuePeek+0x8e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
     e10:	ce 01       	movw	r24, r28
     e12:	01 96       	adiw	r24, 0x01	; 1
     e14:	0e 94 45 0b 	call	0x168a	; 0x168a <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     e18:	ba 2c       	mov	r11, r10
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     e1a:	0f 90       	pop	r0
     e1c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     e1e:	0e 94 31 09 	call	0x1262	; 0x1262 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     e22:	0f b6       	in	r0, 0x3f	; 63
     e24:	f8 94       	cli
     e26:	0f 92       	push	r0
     e28:	f8 01       	movw	r30, r16
     e2a:	85 8d       	ldd	r24, Z+29	; 0x1d
     e2c:	8f 3f       	cpi	r24, 0xFF	; 255
     e2e:	09 f4       	brne	.+2      	; 0xe32 <xQueuePeek+0xa6>
     e30:	15 8e       	std	Z+29, r1	; 0x1d
     e32:	f8 01       	movw	r30, r16
     e34:	86 8d       	ldd	r24, Z+30	; 0x1e
     e36:	8f 3f       	cpi	r24, 0xFF	; 255
     e38:	09 f4       	brne	.+2      	; 0xe3c <xQueuePeek+0xb0>
     e3a:	16 8e       	std	Z+30, r1	; 0x1e
     e3c:	0f 90       	pop	r0
     e3e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     e40:	be 01       	movw	r22, r28
     e42:	6c 5f       	subi	r22, 0xFC	; 252
     e44:	7f 4f       	sbci	r23, 0xFF	; 255
     e46:	ce 01       	movw	r24, r28
     e48:	01 96       	adiw	r24, 0x01	; 1
     e4a:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <xTaskCheckForTimeOut>
     e4e:	81 11       	cpse	r24, r1
     e50:	1a c0       	rjmp	.+52     	; 0xe86 <xQueuePeek+0xfa>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     e52:	c8 01       	movw	r24, r16
     e54:	0e 94 5e 04 	call	0x8bc	; 0x8bc <prvIsQueueEmpty>
     e58:	88 23       	and	r24, r24
     e5a:	79 f0       	breq	.+30     	; 0xe7a <xQueuePeek+0xee>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     e5c:	6c 81       	ldd	r22, Y+4	; 0x04
     e5e:	7d 81       	ldd	r23, Y+5	; 0x05
     e60:	c7 01       	movw	r24, r14
     e62:	0e 94 eb 0a 	call	0x15d6	; 0x15d6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     e66:	c8 01       	movw	r24, r16
     e68:	0e 94 cc 04 	call	0x998	; 0x998 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     e6c:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <xTaskResumeAll>
     e70:	81 11       	cpse	r24, r1
     e72:	a6 cf       	rjmp	.-180    	; 0xdc0 <xQueuePeek+0x34>
				{
					portYIELD_WITHIN_API();
     e74:	0e 94 a6 03 	call	0x74c	; 0x74c <vPortYield>
     e78:	a3 cf       	rjmp	.-186    	; 0xdc0 <xQueuePeek+0x34>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
     e7a:	c8 01       	movw	r24, r16
     e7c:	0e 94 cc 04 	call	0x998	; 0x998 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     e80:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <xTaskResumeAll>
     e84:	9d cf       	rjmp	.-198    	; 0xdc0 <xQueuePeek+0x34>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
     e86:	c8 01       	movw	r24, r16
     e88:	0e 94 cc 04 	call	0x998	; 0x998 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     e8c:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     e90:	c8 01       	movw	r24, r16
     e92:	0e 94 5e 04 	call	0x8bc	; 0x8bc <prvIsQueueEmpty>
     e96:	88 23       	and	r24, r24
     e98:	09 f4       	brne	.+2      	; 0xe9c <xQueuePeek+0x110>
     e9a:	92 cf       	rjmp	.-220    	; 0xdc0 <xQueuePeek+0x34>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
     e9c:	80 e0       	ldi	r24, 0x00	; 0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
     e9e:	0f 90       	pop	r0
     ea0:	0f 90       	pop	r0
     ea2:	0f 90       	pop	r0
     ea4:	0f 90       	pop	r0
     ea6:	0f 90       	pop	r0
     ea8:	df 91       	pop	r29
     eaa:	cf 91       	pop	r28
     eac:	1f 91       	pop	r17
     eae:	0f 91       	pop	r16
     eb0:	ff 90       	pop	r15
     eb2:	ef 90       	pop	r14
     eb4:	df 90       	pop	r13
     eb6:	cf 90       	pop	r12
     eb8:	bf 90       	pop	r11
     eba:	af 90       	pop	r10
     ebc:	08 95       	ret

00000ebe <prvResetNextTaskUnblockTime>:
	taskENTER_CRITICAL();
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
		pxTimeOut->xTimeOnEntering = xTickCount;
	}
	taskEXIT_CRITICAL();
     ebe:	e0 91 82 06 	lds	r30, 0x0682	; 0x800682 <pxDelayedTaskList>
     ec2:	f0 91 83 06 	lds	r31, 0x0683	; 0x800683 <pxDelayedTaskList+0x1>
     ec6:	80 81       	ld	r24, Z
     ec8:	81 11       	cpse	r24, r1
     eca:	07 c0       	rjmp	.+14     	; 0xeda <prvResetNextTaskUnblockTime+0x1c>
     ecc:	8f ef       	ldi	r24, 0xFF	; 255
     ece:	9f ef       	ldi	r25, 0xFF	; 255
     ed0:	90 93 63 06 	sts	0x0663, r25	; 0x800663 <xNextTaskUnblockTime+0x1>
     ed4:	80 93 62 06 	sts	0x0662, r24	; 0x800662 <xNextTaskUnblockTime>
     ed8:	08 95       	ret
     eda:	e0 91 82 06 	lds	r30, 0x0682	; 0x800682 <pxDelayedTaskList>
     ede:	f0 91 83 06 	lds	r31, 0x0683	; 0x800683 <pxDelayedTaskList+0x1>
     ee2:	05 80       	ldd	r0, Z+5	; 0x05
     ee4:	f6 81       	ldd	r31, Z+6	; 0x06
     ee6:	e0 2d       	mov	r30, r0
     ee8:	06 80       	ldd	r0, Z+6	; 0x06
     eea:	f7 81       	ldd	r31, Z+7	; 0x07
     eec:	e0 2d       	mov	r30, r0
     eee:	82 81       	ldd	r24, Z+2	; 0x02
     ef0:	93 81       	ldd	r25, Z+3	; 0x03
     ef2:	90 93 63 06 	sts	0x0663, r25	; 0x800663 <xNextTaskUnblockTime+0x1>
     ef6:	80 93 62 06 	sts	0x0662, r24	; 0x800662 <xNextTaskUnblockTime>
     efa:	08 95       	ret

00000efc <prvIdleTask>:
     efc:	0e e6       	ldi	r16, 0x6E	; 110
     efe:	16 e0       	ldi	r17, 0x06	; 6
     f00:	0f 2e       	mov	r0, r31
     f02:	f6 e9       	ldi	r31, 0x96	; 150
     f04:	ef 2e       	mov	r14, r31
     f06:	f6 e0       	ldi	r31, 0x06	; 6
     f08:	ff 2e       	mov	r15, r31
     f0a:	f0 2d       	mov	r31, r0
     f0c:	80 91 6d 06 	lds	r24, 0x066D	; 0x80066d <uxDeletedTasksWaitingCleanUp>
     f10:	88 23       	and	r24, r24
     f12:	29 f1       	breq	.+74     	; 0xf5e <prvIdleTask+0x62>
     f14:	0f b6       	in	r0, 0x3f	; 63
     f16:	f8 94       	cli
     f18:	0f 92       	push	r0
     f1a:	d8 01       	movw	r26, r16
     f1c:	15 96       	adiw	r26, 0x05	; 5
     f1e:	ed 91       	ld	r30, X+
     f20:	fc 91       	ld	r31, X
     f22:	16 97       	sbiw	r26, 0x06	; 6
     f24:	c6 81       	ldd	r28, Z+6	; 0x06
     f26:	d7 81       	ldd	r29, Z+7	; 0x07
     f28:	ce 01       	movw	r24, r28
     f2a:	02 96       	adiw	r24, 0x02	; 2
     f2c:	0e 94 40 02 	call	0x480	; 0x480 <uxListRemove>
     f30:	80 91 6c 06 	lds	r24, 0x066C	; 0x80066c <uxCurrentNumberOfTasks>
     f34:	81 50       	subi	r24, 0x01	; 1
     f36:	80 93 6c 06 	sts	0x066C, r24	; 0x80066c <uxCurrentNumberOfTasks>
     f3a:	80 91 6d 06 	lds	r24, 0x066D	; 0x80066d <uxDeletedTasksWaitingCleanUp>
     f3e:	81 50       	subi	r24, 0x01	; 1
     f40:	80 93 6d 06 	sts	0x066D, r24	; 0x80066d <uxDeletedTasksWaitingCleanUp>
     f44:	0f 90       	pop	r0
     f46:	0f be       	out	0x3f, r0	; 63
     f48:	8f 89       	ldd	r24, Y+23	; 0x17
     f4a:	98 8d       	ldd	r25, Y+24	; 0x18
     f4c:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
     f50:	ce 01       	movw	r24, r28
     f52:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
     f56:	80 91 6d 06 	lds	r24, 0x066D	; 0x80066d <uxDeletedTasksWaitingCleanUp>
     f5a:	81 11       	cpse	r24, r1
     f5c:	db cf       	rjmp	.-74     	; 0xf14 <prvIdleTask+0x18>
     f5e:	f7 01       	movw	r30, r14
     f60:	80 81       	ld	r24, Z
     f62:	82 30       	cpi	r24, 0x02	; 2
     f64:	98 f2       	brcs	.-90     	; 0xf0c <prvIdleTask+0x10>
     f66:	0e 94 a6 03 	call	0x74c	; 0x74c <vPortYield>
     f6a:	d0 cf       	rjmp	.-96     	; 0xf0c <prvIdleTask+0x10>

00000f6c <prvAddCurrentTaskToDelayedList>:
     f6c:	0f 93       	push	r16
     f6e:	1f 93       	push	r17
     f70:	cf 93       	push	r28
     f72:	df 93       	push	r29
     f74:	ec 01       	movw	r28, r24
     f76:	00 91 6a 06 	lds	r16, 0x066A	; 0x80066a <xTickCount>
     f7a:	10 91 6b 06 	lds	r17, 0x066B	; 0x80066b <xTickCount+0x1>
     f7e:	80 91 ba 06 	lds	r24, 0x06BA	; 0x8006ba <pxCurrentTCB>
     f82:	90 91 bb 06 	lds	r25, 0x06BB	; 0x8006bb <pxCurrentTCB+0x1>
     f86:	02 96       	adiw	r24, 0x02	; 2
     f88:	0e 94 40 02 	call	0x480	; 0x480 <uxListRemove>
     f8c:	c0 0f       	add	r28, r16
     f8e:	d1 1f       	adc	r29, r17
     f90:	e0 91 ba 06 	lds	r30, 0x06BA	; 0x8006ba <pxCurrentTCB>
     f94:	f0 91 bb 06 	lds	r31, 0x06BB	; 0x8006bb <pxCurrentTCB+0x1>
     f98:	d3 83       	std	Z+3, r29	; 0x03
     f9a:	c2 83       	std	Z+2, r28	; 0x02
     f9c:	c0 17       	cp	r28, r16
     f9e:	d1 07       	cpc	r29, r17
     fa0:	68 f4       	brcc	.+26     	; 0xfbc <prvAddCurrentTaskToDelayedList+0x50>
     fa2:	60 91 ba 06 	lds	r22, 0x06BA	; 0x8006ba <pxCurrentTCB>
     fa6:	70 91 bb 06 	lds	r23, 0x06BB	; 0x8006bb <pxCurrentTCB+0x1>
     faa:	80 91 80 06 	lds	r24, 0x0680	; 0x800680 <pxOverflowDelayedTaskList>
     fae:	90 91 81 06 	lds	r25, 0x0681	; 0x800681 <pxOverflowDelayedTaskList+0x1>
     fb2:	6e 5f       	subi	r22, 0xFE	; 254
     fb4:	7f 4f       	sbci	r23, 0xFF	; 255
     fb6:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInsert>
     fba:	17 c0       	rjmp	.+46     	; 0xfea <prvAddCurrentTaskToDelayedList+0x7e>
     fbc:	60 91 ba 06 	lds	r22, 0x06BA	; 0x8006ba <pxCurrentTCB>
     fc0:	70 91 bb 06 	lds	r23, 0x06BB	; 0x8006bb <pxCurrentTCB+0x1>
     fc4:	80 91 82 06 	lds	r24, 0x0682	; 0x800682 <pxDelayedTaskList>
     fc8:	90 91 83 06 	lds	r25, 0x0683	; 0x800683 <pxDelayedTaskList+0x1>
     fcc:	6e 5f       	subi	r22, 0xFE	; 254
     fce:	7f 4f       	sbci	r23, 0xFF	; 255
     fd0:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInsert>
     fd4:	80 91 62 06 	lds	r24, 0x0662	; 0x800662 <xNextTaskUnblockTime>
     fd8:	90 91 63 06 	lds	r25, 0x0663	; 0x800663 <xNextTaskUnblockTime+0x1>
     fdc:	c8 17       	cp	r28, r24
     fde:	d9 07       	cpc	r29, r25
     fe0:	20 f4       	brcc	.+8      	; 0xfea <prvAddCurrentTaskToDelayedList+0x7e>
     fe2:	d0 93 63 06 	sts	0x0663, r29	; 0x800663 <xNextTaskUnblockTime+0x1>
     fe6:	c0 93 62 06 	sts	0x0662, r28	; 0x800662 <xNextTaskUnblockTime>
     fea:	df 91       	pop	r29
     fec:	cf 91       	pop	r28
     fee:	1f 91       	pop	r17
     ff0:	0f 91       	pop	r16
     ff2:	08 95       	ret

00000ff4 <xTaskCreate>:
     ff4:	4f 92       	push	r4
     ff6:	5f 92       	push	r5
     ff8:	6f 92       	push	r6
     ffa:	7f 92       	push	r7
     ffc:	8f 92       	push	r8
     ffe:	9f 92       	push	r9
    1000:	af 92       	push	r10
    1002:	bf 92       	push	r11
    1004:	cf 92       	push	r12
    1006:	df 92       	push	r13
    1008:	ef 92       	push	r14
    100a:	ff 92       	push	r15
    100c:	0f 93       	push	r16
    100e:	cf 93       	push	r28
    1010:	df 93       	push	r29
    1012:	4c 01       	movw	r8, r24
    1014:	6b 01       	movw	r12, r22
    1016:	5a 01       	movw	r10, r20
    1018:	29 01       	movw	r4, r18
    101a:	ca 01       	movw	r24, r20
    101c:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    1020:	3c 01       	movw	r6, r24
    1022:	89 2b       	or	r24, r25
    1024:	09 f4       	brne	.+2      	; 0x1028 <xTaskCreate+0x34>
    1026:	e2 c0       	rjmp	.+452    	; 0x11ec <xTaskCreate+0x1f8>
    1028:	86 e2       	ldi	r24, 0x26	; 38
    102a:	90 e0       	ldi	r25, 0x00	; 0
    102c:	0e 94 49 00 	call	0x92	; 0x92 <pvPortMalloc>
    1030:	ec 01       	movw	r28, r24
    1032:	89 2b       	or	r24, r25
    1034:	59 f0       	breq	.+22     	; 0x104c <xTaskCreate+0x58>
    1036:	78 8e       	std	Y+24, r7	; 0x18
    1038:	6f 8a       	std	Y+23, r6	; 0x17
    103a:	81 e0       	ldi	r24, 0x01	; 1
    103c:	a8 1a       	sub	r10, r24
    103e:	b1 08       	sbc	r11, r1
    1040:	a6 0c       	add	r10, r6
    1042:	b7 1c       	adc	r11, r7
    1044:	c1 14       	cp	r12, r1
    1046:	d1 04       	cpc	r13, r1
    1048:	29 f4       	brne	.+10     	; 0x1054 <xTaskCreate+0x60>
    104a:	20 c0       	rjmp	.+64     	; 0x108c <xTaskCreate+0x98>
    104c:	c3 01       	movw	r24, r6
    104e:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <vPortFree>
    1052:	cc c0       	rjmp	.+408    	; 0x11ec <xTaskCreate+0x1f8>
    1054:	d6 01       	movw	r26, r12
    1056:	8c 91       	ld	r24, X
    1058:	89 8f       	std	Y+25, r24	; 0x19
    105a:	8c 91       	ld	r24, X
    105c:	88 23       	and	r24, r24
    105e:	a1 f0       	breq	.+40     	; 0x1088 <xTaskCreate+0x94>
    1060:	ae 01       	movw	r20, r28
    1062:	46 5e       	subi	r20, 0xE6	; 230
    1064:	5f 4f       	sbci	r21, 0xFF	; 255
    1066:	f6 01       	movw	r30, r12
    1068:	31 96       	adiw	r30, 0x01	; 1
    106a:	b8 e0       	ldi	r27, 0x08	; 8
    106c:	cb 0e       	add	r12, r27
    106e:	d1 1c       	adc	r13, r1
    1070:	cf 01       	movw	r24, r30
    1072:	21 91       	ld	r18, Z+
    1074:	da 01       	movw	r26, r20
    1076:	2d 93       	st	X+, r18
    1078:	ad 01       	movw	r20, r26
    107a:	dc 01       	movw	r26, r24
    107c:	8c 91       	ld	r24, X
    107e:	88 23       	and	r24, r24
    1080:	19 f0       	breq	.+6      	; 0x1088 <xTaskCreate+0x94>
    1082:	ec 15       	cp	r30, r12
    1084:	fd 05       	cpc	r31, r13
    1086:	a1 f7       	brne	.-24     	; 0x1070 <xTaskCreate+0x7c>
    1088:	18 a2       	std	Y+32, r1	; 0x20
    108a:	01 c0       	rjmp	.+2      	; 0x108e <xTaskCreate+0x9a>
    108c:	19 8e       	std	Y+25, r1	; 0x19
    108e:	04 30       	cpi	r16, 0x04	; 4
    1090:	08 f0       	brcs	.+2      	; 0x1094 <xTaskCreate+0xa0>
    1092:	03 e0       	ldi	r16, 0x03	; 3
    1094:	0e 8b       	std	Y+22, r16	; 0x16
    1096:	6e 01       	movw	r12, r28
    1098:	b2 e0       	ldi	r27, 0x02	; 2
    109a:	cb 0e       	add	r12, r27
    109c:	d1 1c       	adc	r13, r1
    109e:	c6 01       	movw	r24, r12
    10a0:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <vListInitialiseItem>
    10a4:	ce 01       	movw	r24, r28
    10a6:	0c 96       	adiw	r24, 0x0c	; 12
    10a8:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <vListInitialiseItem>
    10ac:	d9 87       	std	Y+9, r29	; 0x09
    10ae:	c8 87       	std	Y+8, r28	; 0x08
    10b0:	84 e0       	ldi	r24, 0x04	; 4
    10b2:	90 e0       	ldi	r25, 0x00	; 0
    10b4:	80 1b       	sub	r24, r16
    10b6:	91 09       	sbc	r25, r1
    10b8:	9d 87       	std	Y+13, r25	; 0x0d
    10ba:	8c 87       	std	Y+12, r24	; 0x0c
    10bc:	db 8b       	std	Y+19, r29	; 0x13
    10be:	ca 8b       	std	Y+18, r28	; 0x12
    10c0:	19 a2       	std	Y+33, r1	; 0x21
    10c2:	1a a2       	std	Y+34, r1	; 0x22
    10c4:	1b a2       	std	Y+35, r1	; 0x23
    10c6:	1c a2       	std	Y+36, r1	; 0x24
    10c8:	1d a2       	std	Y+37, r1	; 0x25
    10ca:	a2 01       	movw	r20, r4
    10cc:	b4 01       	movw	r22, r8
    10ce:	c5 01       	movw	r24, r10
    10d0:	0e 94 05 03 	call	0x60a	; 0x60a <pxPortInitialiseStack>
    10d4:	99 83       	std	Y+1, r25	; 0x01
    10d6:	88 83       	st	Y, r24
    10d8:	e1 14       	cp	r14, r1
    10da:	f1 04       	cpc	r15, r1
    10dc:	19 f0       	breq	.+6      	; 0x10e4 <xTaskCreate+0xf0>
    10de:	f7 01       	movw	r30, r14
    10e0:	d1 83       	std	Z+1, r29	; 0x01
    10e2:	c0 83       	st	Z, r28
    10e4:	0f b6       	in	r0, 0x3f	; 63
    10e6:	f8 94       	cli
    10e8:	0f 92       	push	r0
    10ea:	80 91 6c 06 	lds	r24, 0x066C	; 0x80066c <uxCurrentNumberOfTasks>
    10ee:	8f 5f       	subi	r24, 0xFF	; 255
    10f0:	80 93 6c 06 	sts	0x066C, r24	; 0x80066c <uxCurrentNumberOfTasks>
    10f4:	80 91 ba 06 	lds	r24, 0x06BA	; 0x8006ba <pxCurrentTCB>
    10f8:	90 91 bb 06 	lds	r25, 0x06BB	; 0x8006bb <pxCurrentTCB+0x1>
    10fc:	89 2b       	or	r24, r25
    10fe:	a9 f5       	brne	.+106    	; 0x116a <xTaskCreate+0x176>
    1100:	d0 93 bb 06 	sts	0x06BB, r29	; 0x8006bb <pxCurrentTCB+0x1>
    1104:	c0 93 ba 06 	sts	0x06BA, r28	; 0x8006ba <pxCurrentTCB>
    1108:	80 91 6c 06 	lds	r24, 0x066C	; 0x80066c <uxCurrentNumberOfTasks>
    110c:	81 30       	cpi	r24, 0x01	; 1
    110e:	e9 f5       	brne	.+122    	; 0x118a <xTaskCreate+0x196>
    1110:	86 e9       	ldi	r24, 0x96	; 150
    1112:	96 e0       	ldi	r25, 0x06	; 6
    1114:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <vListInitialise>
    1118:	8f e9       	ldi	r24, 0x9F	; 159
    111a:	96 e0       	ldi	r25, 0x06	; 6
    111c:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <vListInitialise>
    1120:	88 ea       	ldi	r24, 0xA8	; 168
    1122:	96 e0       	ldi	r25, 0x06	; 6
    1124:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <vListInitialise>
    1128:	81 eb       	ldi	r24, 0xB1	; 177
    112a:	96 e0       	ldi	r25, 0x06	; 6
    112c:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <vListInitialise>
    1130:	8d e8       	ldi	r24, 0x8D	; 141
    1132:	96 e0       	ldi	r25, 0x06	; 6
    1134:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <vListInitialise>
    1138:	84 e8       	ldi	r24, 0x84	; 132
    113a:	96 e0       	ldi	r25, 0x06	; 6
    113c:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <vListInitialise>
    1140:	87 e7       	ldi	r24, 0x77	; 119
    1142:	96 e0       	ldi	r25, 0x06	; 6
    1144:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <vListInitialise>
    1148:	8e e6       	ldi	r24, 0x6E	; 110
    114a:	96 e0       	ldi	r25, 0x06	; 6
    114c:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <vListInitialise>
    1150:	8d e8       	ldi	r24, 0x8D	; 141
    1152:	96 e0       	ldi	r25, 0x06	; 6
    1154:	90 93 83 06 	sts	0x0683, r25	; 0x800683 <pxDelayedTaskList+0x1>
    1158:	80 93 82 06 	sts	0x0682, r24	; 0x800682 <pxDelayedTaskList>
    115c:	84 e8       	ldi	r24, 0x84	; 132
    115e:	96 e0       	ldi	r25, 0x06	; 6
    1160:	90 93 81 06 	sts	0x0681, r25	; 0x800681 <pxOverflowDelayedTaskList+0x1>
    1164:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <pxOverflowDelayedTaskList>
    1168:	10 c0       	rjmp	.+32     	; 0x118a <xTaskCreate+0x196>
    116a:	80 91 68 06 	lds	r24, 0x0668	; 0x800668 <xSchedulerRunning>
    116e:	81 11       	cpse	r24, r1
    1170:	0c c0       	rjmp	.+24     	; 0x118a <xTaskCreate+0x196>
    1172:	e0 91 ba 06 	lds	r30, 0x06BA	; 0x8006ba <pxCurrentTCB>
    1176:	f0 91 bb 06 	lds	r31, 0x06BB	; 0x8006bb <pxCurrentTCB+0x1>
    117a:	96 89       	ldd	r25, Z+22	; 0x16
    117c:	8e 89       	ldd	r24, Y+22	; 0x16
    117e:	89 17       	cp	r24, r25
    1180:	20 f0       	brcs	.+8      	; 0x118a <xTaskCreate+0x196>
    1182:	d0 93 bb 06 	sts	0x06BB, r29	; 0x8006bb <pxCurrentTCB+0x1>
    1186:	c0 93 ba 06 	sts	0x06BA, r28	; 0x8006ba <pxCurrentTCB>
    118a:	80 91 64 06 	lds	r24, 0x0664	; 0x800664 <uxTaskNumber>
    118e:	8f 5f       	subi	r24, 0xFF	; 255
    1190:	80 93 64 06 	sts	0x0664, r24	; 0x800664 <uxTaskNumber>
    1194:	8e 89       	ldd	r24, Y+22	; 0x16
    1196:	90 91 69 06 	lds	r25, 0x0669	; 0x800669 <uxTopReadyPriority>
    119a:	98 17       	cp	r25, r24
    119c:	10 f4       	brcc	.+4      	; 0x11a2 <xTaskCreate+0x1ae>
    119e:	80 93 69 06 	sts	0x0669, r24	; 0x800669 <uxTopReadyPriority>
    11a2:	90 e0       	ldi	r25, 0x00	; 0
    11a4:	9c 01       	movw	r18, r24
    11a6:	22 0f       	add	r18, r18
    11a8:	33 1f       	adc	r19, r19
    11aa:	22 0f       	add	r18, r18
    11ac:	33 1f       	adc	r19, r19
    11ae:	22 0f       	add	r18, r18
    11b0:	33 1f       	adc	r19, r19
    11b2:	82 0f       	add	r24, r18
    11b4:	93 1f       	adc	r25, r19
    11b6:	b6 01       	movw	r22, r12
    11b8:	8a 56       	subi	r24, 0x6A	; 106
    11ba:	99 4f       	sbci	r25, 0xF9	; 249
    11bc:	0e 94 ee 01 	call	0x3dc	; 0x3dc <vListInsertEnd>
    11c0:	0f 90       	pop	r0
    11c2:	0f be       	out	0x3f, r0	; 63
    11c4:	80 91 68 06 	lds	r24, 0x0668	; 0x800668 <xSchedulerRunning>
    11c8:	88 23       	and	r24, r24
    11ca:	61 f0       	breq	.+24     	; 0x11e4 <xTaskCreate+0x1f0>
    11cc:	e0 91 ba 06 	lds	r30, 0x06BA	; 0x8006ba <pxCurrentTCB>
    11d0:	f0 91 bb 06 	lds	r31, 0x06BB	; 0x8006bb <pxCurrentTCB+0x1>
    11d4:	96 89       	ldd	r25, Z+22	; 0x16
    11d6:	8e 89       	ldd	r24, Y+22	; 0x16
    11d8:	98 17       	cp	r25, r24
    11da:	30 f4       	brcc	.+12     	; 0x11e8 <xTaskCreate+0x1f4>
    11dc:	0e 94 a6 03 	call	0x74c	; 0x74c <vPortYield>
    11e0:	81 e0       	ldi	r24, 0x01	; 1
    11e2:	05 c0       	rjmp	.+10     	; 0x11ee <xTaskCreate+0x1fa>
    11e4:	81 e0       	ldi	r24, 0x01	; 1
    11e6:	03 c0       	rjmp	.+6      	; 0x11ee <xTaskCreate+0x1fa>
    11e8:	81 e0       	ldi	r24, 0x01	; 1
    11ea:	01 c0       	rjmp	.+2      	; 0x11ee <xTaskCreate+0x1fa>
    11ec:	8f ef       	ldi	r24, 0xFF	; 255
    11ee:	df 91       	pop	r29
    11f0:	cf 91       	pop	r28
    11f2:	0f 91       	pop	r16
    11f4:	ff 90       	pop	r15
    11f6:	ef 90       	pop	r14
    11f8:	df 90       	pop	r13
    11fa:	cf 90       	pop	r12
    11fc:	bf 90       	pop	r11
    11fe:	af 90       	pop	r10
    1200:	9f 90       	pop	r9
    1202:	8f 90       	pop	r8
    1204:	7f 90       	pop	r7
    1206:	6f 90       	pop	r6
    1208:	5f 90       	pop	r5
    120a:	4f 90       	pop	r4
    120c:	08 95       	ret

0000120e <vTaskStartScheduler>:
    120e:	ef 92       	push	r14
    1210:	ff 92       	push	r15
    1212:	0f 93       	push	r16
    1214:	0f 2e       	mov	r0, r31
    1216:	f0 e6       	ldi	r31, 0x60	; 96
    1218:	ef 2e       	mov	r14, r31
    121a:	f6 e0       	ldi	r31, 0x06	; 6
    121c:	ff 2e       	mov	r15, r31
    121e:	f0 2d       	mov	r31, r0
    1220:	00 e0       	ldi	r16, 0x00	; 0
    1222:	20 e0       	ldi	r18, 0x00	; 0
    1224:	30 e0       	ldi	r19, 0x00	; 0
    1226:	45 e5       	ldi	r20, 0x55	; 85
    1228:	50 e0       	ldi	r21, 0x00	; 0
    122a:	65 e7       	ldi	r22, 0x75	; 117
    122c:	70 e0       	ldi	r23, 0x00	; 0
    122e:	8e e7       	ldi	r24, 0x7E	; 126
    1230:	97 e0       	ldi	r25, 0x07	; 7
    1232:	0e 94 fa 07 	call	0xff4	; 0xff4 <xTaskCreate>
    1236:	81 30       	cpi	r24, 0x01	; 1
    1238:	81 f4       	brne	.+32     	; 0x125a <vTaskStartScheduler+0x4c>
    123a:	f8 94       	cli
    123c:	8f ef       	ldi	r24, 0xFF	; 255
    123e:	9f ef       	ldi	r25, 0xFF	; 255
    1240:	90 93 63 06 	sts	0x0663, r25	; 0x800663 <xNextTaskUnblockTime+0x1>
    1244:	80 93 62 06 	sts	0x0662, r24	; 0x800662 <xNextTaskUnblockTime>
    1248:	81 e0       	ldi	r24, 0x01	; 1
    124a:	80 93 68 06 	sts	0x0668, r24	; 0x800668 <xSchedulerRunning>
    124e:	10 92 6b 06 	sts	0x066B, r1	; 0x80066b <xTickCount+0x1>
    1252:	10 92 6a 06 	sts	0x066A, r1	; 0x80066a <xTickCount>
    1256:	0e 94 71 03 	call	0x6e2	; 0x6e2 <xPortStartScheduler>
    125a:	0f 91       	pop	r16
    125c:	ff 90       	pop	r15
    125e:	ef 90       	pop	r14
    1260:	08 95       	ret

00001262 <vTaskSuspendAll>:
    1262:	80 91 5f 06 	lds	r24, 0x065F	; 0x80065f <uxSchedulerSuspended>
    1266:	8f 5f       	subi	r24, 0xFF	; 255
    1268:	80 93 5f 06 	sts	0x065F, r24	; 0x80065f <uxSchedulerSuspended>
    126c:	08 95       	ret

0000126e <xTaskIncrementTick>:
    126e:	cf 92       	push	r12
    1270:	df 92       	push	r13
    1272:	ef 92       	push	r14
    1274:	ff 92       	push	r15
    1276:	0f 93       	push	r16
    1278:	1f 93       	push	r17
    127a:	cf 93       	push	r28
    127c:	df 93       	push	r29
    127e:	80 91 5f 06 	lds	r24, 0x065F	; 0x80065f <uxSchedulerSuspended>
    1282:	81 11       	cpse	r24, r1
    1284:	99 c0       	rjmp	.+306    	; 0x13b8 <xTaskIncrementTick+0x14a>
    1286:	e0 90 6a 06 	lds	r14, 0x066A	; 0x80066a <xTickCount>
    128a:	f0 90 6b 06 	lds	r15, 0x066B	; 0x80066b <xTickCount+0x1>
    128e:	8f ef       	ldi	r24, 0xFF	; 255
    1290:	e8 1a       	sub	r14, r24
    1292:	f8 0a       	sbc	r15, r24
    1294:	f0 92 6b 06 	sts	0x066B, r15	; 0x80066b <xTickCount+0x1>
    1298:	e0 92 6a 06 	sts	0x066A, r14	; 0x80066a <xTickCount>
    129c:	e1 14       	cp	r14, r1
    129e:	f1 04       	cpc	r15, r1
    12a0:	b9 f4       	brne	.+46     	; 0x12d0 <xTaskIncrementTick+0x62>
    12a2:	80 91 82 06 	lds	r24, 0x0682	; 0x800682 <pxDelayedTaskList>
    12a6:	90 91 83 06 	lds	r25, 0x0683	; 0x800683 <pxDelayedTaskList+0x1>
    12aa:	20 91 80 06 	lds	r18, 0x0680	; 0x800680 <pxOverflowDelayedTaskList>
    12ae:	30 91 81 06 	lds	r19, 0x0681	; 0x800681 <pxOverflowDelayedTaskList+0x1>
    12b2:	30 93 83 06 	sts	0x0683, r19	; 0x800683 <pxDelayedTaskList+0x1>
    12b6:	20 93 82 06 	sts	0x0682, r18	; 0x800682 <pxDelayedTaskList>
    12ba:	90 93 81 06 	sts	0x0681, r25	; 0x800681 <pxOverflowDelayedTaskList+0x1>
    12be:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <pxOverflowDelayedTaskList>
    12c2:	80 91 65 06 	lds	r24, 0x0665	; 0x800665 <xNumOfOverflows>
    12c6:	8f 5f       	subi	r24, 0xFF	; 255
    12c8:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <xNumOfOverflows>
    12cc:	0e 94 5f 07 	call	0xebe	; 0xebe <prvResetNextTaskUnblockTime>
    12d0:	80 91 62 06 	lds	r24, 0x0662	; 0x800662 <xNextTaskUnblockTime>
    12d4:	90 91 63 06 	lds	r25, 0x0663	; 0x800663 <xNextTaskUnblockTime+0x1>
    12d8:	e8 16       	cp	r14, r24
    12da:	f9 06       	cpc	r15, r25
    12dc:	10 f4       	brcc	.+4      	; 0x12e2 <xTaskIncrementTick+0x74>
    12de:	d1 2c       	mov	r13, r1
    12e0:	53 c0       	rjmp	.+166    	; 0x1388 <xTaskIncrementTick+0x11a>
    12e2:	d1 2c       	mov	r13, r1
    12e4:	cc 24       	eor	r12, r12
    12e6:	c3 94       	inc	r12
    12e8:	e0 91 82 06 	lds	r30, 0x0682	; 0x800682 <pxDelayedTaskList>
    12ec:	f0 91 83 06 	lds	r31, 0x0683	; 0x800683 <pxDelayedTaskList+0x1>
    12f0:	80 81       	ld	r24, Z
    12f2:	81 11       	cpse	r24, r1
    12f4:	07 c0       	rjmp	.+14     	; 0x1304 <xTaskIncrementTick+0x96>
    12f6:	8f ef       	ldi	r24, 0xFF	; 255
    12f8:	9f ef       	ldi	r25, 0xFF	; 255
    12fa:	90 93 63 06 	sts	0x0663, r25	; 0x800663 <xNextTaskUnblockTime+0x1>
    12fe:	80 93 62 06 	sts	0x0662, r24	; 0x800662 <xNextTaskUnblockTime>
    1302:	42 c0       	rjmp	.+132    	; 0x1388 <xTaskIncrementTick+0x11a>
    1304:	e0 91 82 06 	lds	r30, 0x0682	; 0x800682 <pxDelayedTaskList>
    1308:	f0 91 83 06 	lds	r31, 0x0683	; 0x800683 <pxDelayedTaskList+0x1>
    130c:	05 80       	ldd	r0, Z+5	; 0x05
    130e:	f6 81       	ldd	r31, Z+6	; 0x06
    1310:	e0 2d       	mov	r30, r0
    1312:	c6 81       	ldd	r28, Z+6	; 0x06
    1314:	d7 81       	ldd	r29, Z+7	; 0x07
    1316:	8a 81       	ldd	r24, Y+2	; 0x02
    1318:	9b 81       	ldd	r25, Y+3	; 0x03
    131a:	e8 16       	cp	r14, r24
    131c:	f9 06       	cpc	r15, r25
    131e:	28 f4       	brcc	.+10     	; 0x132a <xTaskIncrementTick+0xbc>
    1320:	90 93 63 06 	sts	0x0663, r25	; 0x800663 <xNextTaskUnblockTime+0x1>
    1324:	80 93 62 06 	sts	0x0662, r24	; 0x800662 <xNextTaskUnblockTime>
    1328:	2f c0       	rjmp	.+94     	; 0x1388 <xTaskIncrementTick+0x11a>
    132a:	8e 01       	movw	r16, r28
    132c:	0e 5f       	subi	r16, 0xFE	; 254
    132e:	1f 4f       	sbci	r17, 0xFF	; 255
    1330:	c8 01       	movw	r24, r16
    1332:	0e 94 40 02 	call	0x480	; 0x480 <uxListRemove>
    1336:	8c 89       	ldd	r24, Y+20	; 0x14
    1338:	9d 89       	ldd	r25, Y+21	; 0x15
    133a:	89 2b       	or	r24, r25
    133c:	21 f0       	breq	.+8      	; 0x1346 <xTaskIncrementTick+0xd8>
    133e:	ce 01       	movw	r24, r28
    1340:	0c 96       	adiw	r24, 0x0c	; 12
    1342:	0e 94 40 02 	call	0x480	; 0x480 <uxListRemove>
    1346:	8e 89       	ldd	r24, Y+22	; 0x16
    1348:	90 91 69 06 	lds	r25, 0x0669	; 0x800669 <uxTopReadyPriority>
    134c:	98 17       	cp	r25, r24
    134e:	10 f4       	brcc	.+4      	; 0x1354 <xTaskIncrementTick+0xe6>
    1350:	80 93 69 06 	sts	0x0669, r24	; 0x800669 <uxTopReadyPriority>
    1354:	90 e0       	ldi	r25, 0x00	; 0
    1356:	9c 01       	movw	r18, r24
    1358:	22 0f       	add	r18, r18
    135a:	33 1f       	adc	r19, r19
    135c:	22 0f       	add	r18, r18
    135e:	33 1f       	adc	r19, r19
    1360:	22 0f       	add	r18, r18
    1362:	33 1f       	adc	r19, r19
    1364:	82 0f       	add	r24, r18
    1366:	93 1f       	adc	r25, r19
    1368:	b8 01       	movw	r22, r16
    136a:	8a 56       	subi	r24, 0x6A	; 106
    136c:	99 4f       	sbci	r25, 0xF9	; 249
    136e:	0e 94 ee 01 	call	0x3dc	; 0x3dc <vListInsertEnd>
    1372:	e0 91 ba 06 	lds	r30, 0x06BA	; 0x8006ba <pxCurrentTCB>
    1376:	f0 91 bb 06 	lds	r31, 0x06BB	; 0x8006bb <pxCurrentTCB+0x1>
    137a:	9e 89       	ldd	r25, Y+22	; 0x16
    137c:	86 89       	ldd	r24, Z+22	; 0x16
    137e:	98 17       	cp	r25, r24
    1380:	08 f4       	brcc	.+2      	; 0x1384 <xTaskIncrementTick+0x116>
    1382:	b2 cf       	rjmp	.-156    	; 0x12e8 <xTaskIncrementTick+0x7a>
    1384:	dc 2c       	mov	r13, r12
    1386:	b0 cf       	rjmp	.-160    	; 0x12e8 <xTaskIncrementTick+0x7a>
    1388:	e0 91 ba 06 	lds	r30, 0x06BA	; 0x8006ba <pxCurrentTCB>
    138c:	f0 91 bb 06 	lds	r31, 0x06BB	; 0x8006bb <pxCurrentTCB+0x1>
    1390:	86 89       	ldd	r24, Z+22	; 0x16
    1392:	90 e0       	ldi	r25, 0x00	; 0
    1394:	fc 01       	movw	r30, r24
    1396:	ee 0f       	add	r30, r30
    1398:	ff 1f       	adc	r31, r31
    139a:	ee 0f       	add	r30, r30
    139c:	ff 1f       	adc	r31, r31
    139e:	ee 0f       	add	r30, r30
    13a0:	ff 1f       	adc	r31, r31
    13a2:	8e 0f       	add	r24, r30
    13a4:	9f 1f       	adc	r25, r31
    13a6:	fc 01       	movw	r30, r24
    13a8:	ea 56       	subi	r30, 0x6A	; 106
    13aa:	f9 4f       	sbci	r31, 0xF9	; 249
    13ac:	80 81       	ld	r24, Z
    13ae:	82 30       	cpi	r24, 0x02	; 2
    13b0:	48 f0       	brcs	.+18     	; 0x13c4 <xTaskIncrementTick+0x156>
    13b2:	dd 24       	eor	r13, r13
    13b4:	d3 94       	inc	r13
    13b6:	06 c0       	rjmp	.+12     	; 0x13c4 <xTaskIncrementTick+0x156>
    13b8:	80 91 67 06 	lds	r24, 0x0667	; 0x800667 <uxPendedTicks>
    13bc:	8f 5f       	subi	r24, 0xFF	; 255
    13be:	80 93 67 06 	sts	0x0667, r24	; 0x800667 <uxPendedTicks>
    13c2:	d1 2c       	mov	r13, r1
    13c4:	80 91 66 06 	lds	r24, 0x0666	; 0x800666 <xYieldPending>
    13c8:	88 23       	and	r24, r24
    13ca:	11 f0       	breq	.+4      	; 0x13d0 <xTaskIncrementTick+0x162>
    13cc:	dd 24       	eor	r13, r13
    13ce:	d3 94       	inc	r13
    13d0:	8d 2d       	mov	r24, r13
    13d2:	df 91       	pop	r29
    13d4:	cf 91       	pop	r28
    13d6:	1f 91       	pop	r17
    13d8:	0f 91       	pop	r16
    13da:	ff 90       	pop	r15
    13dc:	ef 90       	pop	r14
    13de:	df 90       	pop	r13
    13e0:	cf 90       	pop	r12
    13e2:	08 95       	ret

000013e4 <xTaskResumeAll>:
    13e4:	df 92       	push	r13
    13e6:	ef 92       	push	r14
    13e8:	ff 92       	push	r15
    13ea:	0f 93       	push	r16
    13ec:	1f 93       	push	r17
    13ee:	cf 93       	push	r28
    13f0:	df 93       	push	r29
    13f2:	0f b6       	in	r0, 0x3f	; 63
    13f4:	f8 94       	cli
    13f6:	0f 92       	push	r0
    13f8:	80 91 5f 06 	lds	r24, 0x065F	; 0x80065f <uxSchedulerSuspended>
    13fc:	81 50       	subi	r24, 0x01	; 1
    13fe:	80 93 5f 06 	sts	0x065F, r24	; 0x80065f <uxSchedulerSuspended>
    1402:	80 91 5f 06 	lds	r24, 0x065F	; 0x80065f <uxSchedulerSuspended>
    1406:	81 11       	cpse	r24, r1
    1408:	5f c0       	rjmp	.+190    	; 0x14c8 <xTaskResumeAll+0xe4>
    140a:	80 91 6c 06 	lds	r24, 0x066C	; 0x80066c <uxCurrentNumberOfTasks>
    140e:	81 11       	cpse	r24, r1
    1410:	33 c0       	rjmp	.+102    	; 0x1478 <xTaskResumeAll+0x94>
    1412:	5d c0       	rjmp	.+186    	; 0x14ce <xTaskResumeAll+0xea>
    1414:	d7 01       	movw	r26, r14
    1416:	15 96       	adiw	r26, 0x05	; 5
    1418:	ed 91       	ld	r30, X+
    141a:	fc 91       	ld	r31, X
    141c:	16 97       	sbiw	r26, 0x06	; 6
    141e:	c6 81       	ldd	r28, Z+6	; 0x06
    1420:	d7 81       	ldd	r29, Z+7	; 0x07
    1422:	ce 01       	movw	r24, r28
    1424:	0c 96       	adiw	r24, 0x0c	; 12
    1426:	0e 94 40 02 	call	0x480	; 0x480 <uxListRemove>
    142a:	8e 01       	movw	r16, r28
    142c:	0e 5f       	subi	r16, 0xFE	; 254
    142e:	1f 4f       	sbci	r17, 0xFF	; 255
    1430:	c8 01       	movw	r24, r16
    1432:	0e 94 40 02 	call	0x480	; 0x480 <uxListRemove>
    1436:	8e 89       	ldd	r24, Y+22	; 0x16
    1438:	90 91 69 06 	lds	r25, 0x0669	; 0x800669 <uxTopReadyPriority>
    143c:	98 17       	cp	r25, r24
    143e:	10 f4       	brcc	.+4      	; 0x1444 <xTaskResumeAll+0x60>
    1440:	80 93 69 06 	sts	0x0669, r24	; 0x800669 <uxTopReadyPriority>
    1444:	90 e0       	ldi	r25, 0x00	; 0
    1446:	9c 01       	movw	r18, r24
    1448:	22 0f       	add	r18, r18
    144a:	33 1f       	adc	r19, r19
    144c:	22 0f       	add	r18, r18
    144e:	33 1f       	adc	r19, r19
    1450:	22 0f       	add	r18, r18
    1452:	33 1f       	adc	r19, r19
    1454:	82 0f       	add	r24, r18
    1456:	93 1f       	adc	r25, r19
    1458:	b8 01       	movw	r22, r16
    145a:	8a 56       	subi	r24, 0x6A	; 106
    145c:	99 4f       	sbci	r25, 0xF9	; 249
    145e:	0e 94 ee 01 	call	0x3dc	; 0x3dc <vListInsertEnd>
    1462:	e0 91 ba 06 	lds	r30, 0x06BA	; 0x8006ba <pxCurrentTCB>
    1466:	f0 91 bb 06 	lds	r31, 0x06BB	; 0x8006bb <pxCurrentTCB+0x1>
    146a:	9e 89       	ldd	r25, Y+22	; 0x16
    146c:	86 89       	ldd	r24, Z+22	; 0x16
    146e:	98 17       	cp	r25, r24
    1470:	68 f0       	brcs	.+26     	; 0x148c <xTaskResumeAll+0xa8>
    1472:	d0 92 66 06 	sts	0x0666, r13	; 0x800666 <xYieldPending>
    1476:	0a c0       	rjmp	.+20     	; 0x148c <xTaskResumeAll+0xa8>
    1478:	c0 e0       	ldi	r28, 0x00	; 0
    147a:	d0 e0       	ldi	r29, 0x00	; 0
    147c:	0f 2e       	mov	r0, r31
    147e:	f7 e7       	ldi	r31, 0x77	; 119
    1480:	ef 2e       	mov	r14, r31
    1482:	f6 e0       	ldi	r31, 0x06	; 6
    1484:	ff 2e       	mov	r15, r31
    1486:	f0 2d       	mov	r31, r0
    1488:	dd 24       	eor	r13, r13
    148a:	d3 94       	inc	r13
    148c:	f7 01       	movw	r30, r14
    148e:	80 81       	ld	r24, Z
    1490:	81 11       	cpse	r24, r1
    1492:	c0 cf       	rjmp	.-128    	; 0x1414 <xTaskResumeAll+0x30>
    1494:	cd 2b       	or	r28, r29
    1496:	11 f0       	breq	.+4      	; 0x149c <xTaskResumeAll+0xb8>
    1498:	0e 94 5f 07 	call	0xebe	; 0xebe <prvResetNextTaskUnblockTime>
    149c:	c0 91 67 06 	lds	r28, 0x0667	; 0x800667 <uxPendedTicks>
    14a0:	cc 23       	and	r28, r28
    14a2:	51 f0       	breq	.+20     	; 0x14b8 <xTaskResumeAll+0xd4>
    14a4:	d1 e0       	ldi	r29, 0x01	; 1
    14a6:	0e 94 37 09 	call	0x126e	; 0x126e <xTaskIncrementTick>
    14aa:	81 11       	cpse	r24, r1
    14ac:	d0 93 66 06 	sts	0x0666, r29	; 0x800666 <xYieldPending>
    14b0:	c1 50       	subi	r28, 0x01	; 1
    14b2:	c9 f7       	brne	.-14     	; 0x14a6 <xTaskResumeAll+0xc2>
    14b4:	10 92 67 06 	sts	0x0667, r1	; 0x800667 <uxPendedTicks>
    14b8:	80 91 66 06 	lds	r24, 0x0666	; 0x800666 <xYieldPending>
    14bc:	88 23       	and	r24, r24
    14be:	31 f0       	breq	.+12     	; 0x14cc <xTaskResumeAll+0xe8>
    14c0:	0e 94 a6 03 	call	0x74c	; 0x74c <vPortYield>
    14c4:	81 e0       	ldi	r24, 0x01	; 1
    14c6:	03 c0       	rjmp	.+6      	; 0x14ce <xTaskResumeAll+0xea>
    14c8:	80 e0       	ldi	r24, 0x00	; 0
    14ca:	01 c0       	rjmp	.+2      	; 0x14ce <xTaskResumeAll+0xea>
    14cc:	80 e0       	ldi	r24, 0x00	; 0
    14ce:	0f 90       	pop	r0
    14d0:	0f be       	out	0x3f, r0	; 63
    14d2:	df 91       	pop	r29
    14d4:	cf 91       	pop	r28
    14d6:	1f 91       	pop	r17
    14d8:	0f 91       	pop	r16
    14da:	ff 90       	pop	r15
    14dc:	ef 90       	pop	r14
    14de:	df 90       	pop	r13
    14e0:	08 95       	ret

000014e2 <vTaskDelay>:
    14e2:	cf 93       	push	r28
    14e4:	df 93       	push	r29
    14e6:	ec 01       	movw	r28, r24
    14e8:	89 2b       	or	r24, r25
    14ea:	51 f0       	breq	.+20     	; 0x1500 <vTaskDelay+0x1e>
    14ec:	0e 94 31 09 	call	0x1262	; 0x1262 <vTaskSuspendAll>
    14f0:	60 e0       	ldi	r22, 0x00	; 0
    14f2:	ce 01       	movw	r24, r28
    14f4:	0e 94 b6 07 	call	0xf6c	; 0xf6c <prvAddCurrentTaskToDelayedList>
    14f8:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <xTaskResumeAll>
    14fc:	81 11       	cpse	r24, r1
    14fe:	02 c0       	rjmp	.+4      	; 0x1504 <vTaskDelay+0x22>
    1500:	0e 94 a6 03 	call	0x74c	; 0x74c <vPortYield>
    1504:	df 91       	pop	r29
    1506:	cf 91       	pop	r28
    1508:	08 95       	ret

0000150a <vTaskSwitchContext>:
    150a:	80 91 5f 06 	lds	r24, 0x065F	; 0x80065f <uxSchedulerSuspended>
    150e:	88 23       	and	r24, r24
    1510:	21 f0       	breq	.+8      	; 0x151a <vTaskSwitchContext+0x10>
    1512:	81 e0       	ldi	r24, 0x01	; 1
    1514:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <xYieldPending>
    1518:	08 95       	ret
    151a:	10 92 66 06 	sts	0x0666, r1	; 0x800666 <xYieldPending>
    151e:	20 91 69 06 	lds	r18, 0x0669	; 0x800669 <uxTopReadyPriority>
    1522:	82 2f       	mov	r24, r18
    1524:	90 e0       	ldi	r25, 0x00	; 0
    1526:	fc 01       	movw	r30, r24
    1528:	ee 0f       	add	r30, r30
    152a:	ff 1f       	adc	r31, r31
    152c:	ee 0f       	add	r30, r30
    152e:	ff 1f       	adc	r31, r31
    1530:	ee 0f       	add	r30, r30
    1532:	ff 1f       	adc	r31, r31
    1534:	e8 0f       	add	r30, r24
    1536:	f9 1f       	adc	r31, r25
    1538:	ea 56       	subi	r30, 0x6A	; 106
    153a:	f9 4f       	sbci	r31, 0xF9	; 249
    153c:	30 81       	ld	r19, Z
    153e:	31 11       	cpse	r19, r1
    1540:	11 c0       	rjmp	.+34     	; 0x1564 <vTaskSwitchContext+0x5a>
    1542:	21 50       	subi	r18, 0x01	; 1
    1544:	82 2f       	mov	r24, r18
    1546:	90 e0       	ldi	r25, 0x00	; 0
    1548:	fc 01       	movw	r30, r24
    154a:	ee 0f       	add	r30, r30
    154c:	ff 1f       	adc	r31, r31
    154e:	ee 0f       	add	r30, r30
    1550:	ff 1f       	adc	r31, r31
    1552:	ee 0f       	add	r30, r30
    1554:	ff 1f       	adc	r31, r31
    1556:	e8 0f       	add	r30, r24
    1558:	f9 1f       	adc	r31, r25
    155a:	ea 56       	subi	r30, 0x6A	; 106
    155c:	f9 4f       	sbci	r31, 0xF9	; 249
    155e:	30 81       	ld	r19, Z
    1560:	33 23       	and	r19, r19
    1562:	79 f3       	breq	.-34     	; 0x1542 <vTaskSwitchContext+0x38>
    1564:	ac 01       	movw	r20, r24
    1566:	44 0f       	add	r20, r20
    1568:	55 1f       	adc	r21, r21
    156a:	44 0f       	add	r20, r20
    156c:	55 1f       	adc	r21, r21
    156e:	44 0f       	add	r20, r20
    1570:	55 1f       	adc	r21, r21
    1572:	48 0f       	add	r20, r24
    1574:	59 1f       	adc	r21, r25
    1576:	da 01       	movw	r26, r20
    1578:	aa 56       	subi	r26, 0x6A	; 106
    157a:	b9 4f       	sbci	r27, 0xF9	; 249
    157c:	11 96       	adiw	r26, 0x01	; 1
    157e:	ed 91       	ld	r30, X+
    1580:	fc 91       	ld	r31, X
    1582:	12 97       	sbiw	r26, 0x02	; 2
    1584:	02 80       	ldd	r0, Z+2	; 0x02
    1586:	f3 81       	ldd	r31, Z+3	; 0x03
    1588:	e0 2d       	mov	r30, r0
    158a:	12 96       	adiw	r26, 0x02	; 2
    158c:	fc 93       	st	X, r31
    158e:	ee 93       	st	-X, r30
    1590:	11 97       	sbiw	r26, 0x01	; 1
    1592:	47 56       	subi	r20, 0x67	; 103
    1594:	59 4f       	sbci	r21, 0xF9	; 249
    1596:	e4 17       	cp	r30, r20
    1598:	f5 07       	cpc	r31, r21
    159a:	29 f4       	brne	.+10     	; 0x15a6 <vTaskSwitchContext+0x9c>
    159c:	42 81       	ldd	r20, Z+2	; 0x02
    159e:	53 81       	ldd	r21, Z+3	; 0x03
    15a0:	fd 01       	movw	r30, r26
    15a2:	52 83       	std	Z+2, r21	; 0x02
    15a4:	41 83       	std	Z+1, r20	; 0x01
    15a6:	fc 01       	movw	r30, r24
    15a8:	ee 0f       	add	r30, r30
    15aa:	ff 1f       	adc	r31, r31
    15ac:	ee 0f       	add	r30, r30
    15ae:	ff 1f       	adc	r31, r31
    15b0:	ee 0f       	add	r30, r30
    15b2:	ff 1f       	adc	r31, r31
    15b4:	8e 0f       	add	r24, r30
    15b6:	9f 1f       	adc	r25, r31
    15b8:	fc 01       	movw	r30, r24
    15ba:	ea 56       	subi	r30, 0x6A	; 106
    15bc:	f9 4f       	sbci	r31, 0xF9	; 249
    15be:	01 80       	ldd	r0, Z+1	; 0x01
    15c0:	f2 81       	ldd	r31, Z+2	; 0x02
    15c2:	e0 2d       	mov	r30, r0
    15c4:	86 81       	ldd	r24, Z+6	; 0x06
    15c6:	97 81       	ldd	r25, Z+7	; 0x07
    15c8:	90 93 bb 06 	sts	0x06BB, r25	; 0x8006bb <pxCurrentTCB+0x1>
    15cc:	80 93 ba 06 	sts	0x06BA, r24	; 0x8006ba <pxCurrentTCB>
    15d0:	20 93 69 06 	sts	0x0669, r18	; 0x800669 <uxTopReadyPriority>
    15d4:	08 95       	ret

000015d6 <vTaskPlaceOnEventList>:
    15d6:	cf 93       	push	r28
    15d8:	df 93       	push	r29
    15da:	eb 01       	movw	r28, r22
    15dc:	60 91 ba 06 	lds	r22, 0x06BA	; 0x8006ba <pxCurrentTCB>
    15e0:	70 91 bb 06 	lds	r23, 0x06BB	; 0x8006bb <pxCurrentTCB+0x1>
    15e4:	64 5f       	subi	r22, 0xF4	; 244
    15e6:	7f 4f       	sbci	r23, 0xFF	; 255
    15e8:	0e 94 0f 02 	call	0x41e	; 0x41e <vListInsert>
    15ec:	61 e0       	ldi	r22, 0x01	; 1
    15ee:	ce 01       	movw	r24, r28
    15f0:	0e 94 b6 07 	call	0xf6c	; 0xf6c <prvAddCurrentTaskToDelayedList>
    15f4:	df 91       	pop	r29
    15f6:	cf 91       	pop	r28
    15f8:	08 95       	ret

000015fa <xTaskRemoveFromEventList>:
    15fa:	0f 93       	push	r16
    15fc:	1f 93       	push	r17
    15fe:	cf 93       	push	r28
    1600:	df 93       	push	r29
    1602:	dc 01       	movw	r26, r24
    1604:	15 96       	adiw	r26, 0x05	; 5
    1606:	ed 91       	ld	r30, X+
    1608:	fc 91       	ld	r31, X
    160a:	16 97       	sbiw	r26, 0x06	; 6
    160c:	c6 81       	ldd	r28, Z+6	; 0x06
    160e:	d7 81       	ldd	r29, Z+7	; 0x07
    1610:	8e 01       	movw	r16, r28
    1612:	04 5f       	subi	r16, 0xF4	; 244
    1614:	1f 4f       	sbci	r17, 0xFF	; 255
    1616:	c8 01       	movw	r24, r16
    1618:	0e 94 40 02 	call	0x480	; 0x480 <uxListRemove>
    161c:	80 91 5f 06 	lds	r24, 0x065F	; 0x80065f <uxSchedulerSuspended>
    1620:	81 11       	cpse	r24, r1
    1622:	1c c0       	rjmp	.+56     	; 0x165c <xTaskRemoveFromEventList+0x62>
    1624:	0a 50       	subi	r16, 0x0A	; 10
    1626:	11 09       	sbc	r17, r1
    1628:	c8 01       	movw	r24, r16
    162a:	0e 94 40 02 	call	0x480	; 0x480 <uxListRemove>
    162e:	8e 89       	ldd	r24, Y+22	; 0x16
    1630:	90 91 69 06 	lds	r25, 0x0669	; 0x800669 <uxTopReadyPriority>
    1634:	98 17       	cp	r25, r24
    1636:	10 f4       	brcc	.+4      	; 0x163c <xTaskRemoveFromEventList+0x42>
    1638:	80 93 69 06 	sts	0x0669, r24	; 0x800669 <uxTopReadyPriority>
    163c:	90 e0       	ldi	r25, 0x00	; 0
    163e:	9c 01       	movw	r18, r24
    1640:	22 0f       	add	r18, r18
    1642:	33 1f       	adc	r19, r19
    1644:	22 0f       	add	r18, r18
    1646:	33 1f       	adc	r19, r19
    1648:	22 0f       	add	r18, r18
    164a:	33 1f       	adc	r19, r19
    164c:	82 0f       	add	r24, r18
    164e:	93 1f       	adc	r25, r19
    1650:	b8 01       	movw	r22, r16
    1652:	8a 56       	subi	r24, 0x6A	; 106
    1654:	99 4f       	sbci	r25, 0xF9	; 249
    1656:	0e 94 ee 01 	call	0x3dc	; 0x3dc <vListInsertEnd>
    165a:	05 c0       	rjmp	.+10     	; 0x1666 <xTaskRemoveFromEventList+0x6c>
    165c:	b8 01       	movw	r22, r16
    165e:	87 e7       	ldi	r24, 0x77	; 119
    1660:	96 e0       	ldi	r25, 0x06	; 6
    1662:	0e 94 ee 01 	call	0x3dc	; 0x3dc <vListInsertEnd>
    1666:	e0 91 ba 06 	lds	r30, 0x06BA	; 0x8006ba <pxCurrentTCB>
    166a:	f0 91 bb 06 	lds	r31, 0x06BB	; 0x8006bb <pxCurrentTCB+0x1>
    166e:	9e 89       	ldd	r25, Y+22	; 0x16
    1670:	86 89       	ldd	r24, Z+22	; 0x16
    1672:	89 17       	cp	r24, r25
    1674:	20 f4       	brcc	.+8      	; 0x167e <xTaskRemoveFromEventList+0x84>
    1676:	81 e0       	ldi	r24, 0x01	; 1
    1678:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <xYieldPending>
    167c:	01 c0       	rjmp	.+2      	; 0x1680 <xTaskRemoveFromEventList+0x86>
    167e:	80 e0       	ldi	r24, 0x00	; 0
    1680:	df 91       	pop	r29
    1682:	cf 91       	pop	r28
    1684:	1f 91       	pop	r17
    1686:	0f 91       	pop	r16
    1688:	08 95       	ret

0000168a <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    168a:	20 91 65 06 	lds	r18, 0x0665	; 0x800665 <xNumOfOverflows>
    168e:	fc 01       	movw	r30, r24
    1690:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1692:	20 91 6a 06 	lds	r18, 0x066A	; 0x80066a <xTickCount>
    1696:	30 91 6b 06 	lds	r19, 0x066B	; 0x80066b <xTickCount+0x1>
    169a:	32 83       	std	Z+2, r19	; 0x02
    169c:	21 83       	std	Z+1, r18	; 0x01
    169e:	08 95       	ret

000016a0 <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    16a0:	0f b6       	in	r0, 0x3f	; 63
    16a2:	f8 94       	cli
    16a4:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    16a6:	20 91 6a 06 	lds	r18, 0x066A	; 0x80066a <xTickCount>
    16aa:	30 91 6b 06 	lds	r19, 0x066B	; 0x80066b <xTickCount+0x1>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    16ae:	dc 01       	movw	r26, r24
    16b0:	11 96       	adiw	r26, 0x01	; 1
    16b2:	4d 91       	ld	r20, X+
    16b4:	5c 91       	ld	r21, X
    16b6:	12 97       	sbiw	r26, 0x02	; 2
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    16b8:	e0 91 65 06 	lds	r30, 0x0665	; 0x800665 <xNumOfOverflows>
    16bc:	fc 91       	ld	r31, X
    16be:	fe 17       	cp	r31, r30
    16c0:	19 f0       	breq	.+6      	; 0x16c8 <xTaskCheckForTimeOut+0x28>
    16c2:	24 17       	cp	r18, r20
    16c4:	35 07       	cpc	r19, r21
    16c6:	a0 f4       	brcc	.+40     	; 0x16f0 <xTaskCheckForTimeOut+0x50>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    16c8:	24 1b       	sub	r18, r20
    16ca:	35 0b       	sbc	r19, r21
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    16cc:	fb 01       	movw	r30, r22
    16ce:	40 81       	ld	r20, Z
    16d0:	51 81       	ldd	r21, Z+1	; 0x01
    16d2:	24 17       	cp	r18, r20
    16d4:	35 07       	cpc	r19, r21
    16d6:	40 f4       	brcc	.+16     	; 0x16e8 <xTaskCheckForTimeOut+0x48>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    16d8:	42 1b       	sub	r20, r18
    16da:	53 0b       	sbc	r21, r19
    16dc:	51 83       	std	Z+1, r21	; 0x01
    16de:	40 83       	st	Z, r20
			vTaskInternalSetTimeOutState( pxTimeOut );
    16e0:	0e 94 45 0b 	call	0x168a	; 0x168a <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    16e4:	80 e0       	ldi	r24, 0x00	; 0
    16e6:	05 c0       	rjmp	.+10     	; 0x16f2 <xTaskCheckForTimeOut+0x52>
		}
		else
		{
			*pxTicksToWait = 0;
    16e8:	11 82       	std	Z+1, r1	; 0x01
    16ea:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    16ec:	81 e0       	ldi	r24, 0x01	; 1
    16ee:	01 c0       	rjmp	.+2      	; 0x16f2 <xTaskCheckForTimeOut+0x52>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    16f0:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    16f2:	0f 90       	pop	r0
    16f4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    16f6:	08 95       	ret

000016f8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    16f8:	81 e0       	ldi	r24, 0x01	; 1
    16fa:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <xYieldPending>
    16fe:	08 95       	ret

00001700 <uartInit_test>:
	 * flag is set to one */
	while(BIT_IS_CLEAR(UCSRA,RXC)){}
	/* Read the received data from the Rx buffer (UDR) and the RXC flag
	   will be cleared after read this data */
    return UDR;
}
    1700:	87 e6       	ldi	r24, 0x67	; 103
    1702:	89 b9       	out	0x09, r24	; 9
    1704:	88 e1       	ldi	r24, 0x18	; 24
    1706:	8a b9       	out	0x0a, r24	; 10
    1708:	86 e8       	ldi	r24, 0x86	; 134
    170a:	80 bd       	out	0x20, r24	; 32
    170c:	08 95       	ret

0000170e <UART_sendByte>:
    170e:	5d 9b       	sbis	0x0b, 5	; 11
    1710:	fe cf       	rjmp	.-4      	; 0x170e <UART_sendByte>
    1712:	8c b9       	out	0x0c, r24	; 12
    1714:	08 95       	ret

00001716 <UART_sendString>:

void UART_sendString(const unsigned char *Str)
{
    1716:	0f 93       	push	r16
    1718:	1f 93       	push	r17
    171a:	cf 93       	push	r28
    171c:	fc 01       	movw	r30, r24
	unsigned char i = 0;
	while(Str[i] != '\0')
    171e:	80 81       	ld	r24, Z
    1720:	88 23       	and	r24, r24
    1722:	59 f0       	breq	.+22     	; 0x173a <UART_sendString+0x24>
    1724:	8f 01       	movw	r16, r30
    1726:	c0 e0       	ldi	r28, 0x00	; 0
	{
		UART_sendByte(Str[i]);
    1728:	0e 94 87 0b 	call	0x170e	; 0x170e <UART_sendByte>
		i++;
    172c:	cf 5f       	subi	r28, 0xFF	; 255
}

void UART_sendString(const unsigned char *Str)
{
	unsigned char i = 0;
	while(Str[i] != '\0')
    172e:	f8 01       	movw	r30, r16
    1730:	ec 0f       	add	r30, r28
    1732:	f1 1d       	adc	r31, r1
    1734:	80 81       	ld	r24, Z
    1736:	81 11       	cpse	r24, r1
    1738:	f7 cf       	rjmp	.-18     	; 0x1728 <UART_sendString+0x12>
	{
		UART_sendByte(Str[i]);
		i++;
	}

}
    173a:	cf 91       	pop	r28
    173c:	1f 91       	pop	r17
    173e:	0f 91       	pop	r16
    1740:	08 95       	ret

00001742 <memcpy>:
    1742:	fb 01       	movw	r30, r22
    1744:	dc 01       	movw	r26, r24
    1746:	02 c0       	rjmp	.+4      	; 0x174c <memcpy+0xa>
    1748:	01 90       	ld	r0, Z+
    174a:	0d 92       	st	X+, r0
    174c:	41 50       	subi	r20, 0x01	; 1
    174e:	50 40       	sbci	r21, 0x00	; 0
    1750:	d8 f7       	brcc	.-10     	; 0x1748 <memcpy+0x6>
    1752:	08 95       	ret

00001754 <itoa>:
    1754:	45 32       	cpi	r20, 0x25	; 37
    1756:	51 05       	cpc	r21, r1
    1758:	20 f4       	brcc	.+8      	; 0x1762 <itoa+0xe>
    175a:	42 30       	cpi	r20, 0x02	; 2
    175c:	10 f0       	brcs	.+4      	; 0x1762 <itoa+0xe>
    175e:	0c 94 b5 0b 	jmp	0x176a	; 0x176a <__itoa_ncheck>
    1762:	fb 01       	movw	r30, r22
    1764:	10 82       	st	Z, r1
    1766:	cb 01       	movw	r24, r22
    1768:	08 95       	ret

0000176a <__itoa_ncheck>:
    176a:	bb 27       	eor	r27, r27
    176c:	4a 30       	cpi	r20, 0x0A	; 10
    176e:	31 f4       	brne	.+12     	; 0x177c <__itoa_ncheck+0x12>
    1770:	99 23       	and	r25, r25
    1772:	22 f4       	brpl	.+8      	; 0x177c <__itoa_ncheck+0x12>
    1774:	bd e2       	ldi	r27, 0x2D	; 45
    1776:	90 95       	com	r25
    1778:	81 95       	neg	r24
    177a:	9f 4f       	sbci	r25, 0xFF	; 255
    177c:	0c 94 c1 0b 	jmp	0x1782	; 0x1782 <__utoa_common>

00001780 <__utoa_ncheck>:
    1780:	bb 27       	eor	r27, r27

00001782 <__utoa_common>:
    1782:	fb 01       	movw	r30, r22
    1784:	55 27       	eor	r21, r21
    1786:	aa 27       	eor	r26, r26
    1788:	88 0f       	add	r24, r24
    178a:	99 1f       	adc	r25, r25
    178c:	aa 1f       	adc	r26, r26
    178e:	a4 17       	cp	r26, r20
    1790:	10 f0       	brcs	.+4      	; 0x1796 <__utoa_common+0x14>
    1792:	a4 1b       	sub	r26, r20
    1794:	83 95       	inc	r24
    1796:	50 51       	subi	r21, 0x10	; 16
    1798:	b9 f7       	brne	.-18     	; 0x1788 <__utoa_common+0x6>
    179a:	a0 5d       	subi	r26, 0xD0	; 208
    179c:	aa 33       	cpi	r26, 0x3A	; 58
    179e:	08 f0       	brcs	.+2      	; 0x17a2 <__utoa_common+0x20>
    17a0:	a9 5d       	subi	r26, 0xD9	; 217
    17a2:	a1 93       	st	Z+, r26
    17a4:	00 97       	sbiw	r24, 0x00	; 0
    17a6:	79 f7       	brne	.-34     	; 0x1786 <__utoa_common+0x4>
    17a8:	b1 11       	cpse	r27, r1
    17aa:	b1 93       	st	Z+, r27
    17ac:	11 92       	st	Z+, r1
    17ae:	cb 01       	movw	r24, r22
    17b0:	0c 94 f3 0d 	jmp	0x1be6	; 0x1be6 <strrev>

000017b4 <sprintf>:
    17b4:	ae e0       	ldi	r26, 0x0E	; 14
    17b6:	b0 e0       	ldi	r27, 0x00	; 0
    17b8:	e0 ee       	ldi	r30, 0xE0	; 224
    17ba:	fb e0       	ldi	r31, 0x0B	; 11
    17bc:	0c 94 ab 0e 	jmp	0x1d56	; 0x1d56 <__prologue_saves__+0x1c>
    17c0:	0d 89       	ldd	r16, Y+21	; 0x15
    17c2:	1e 89       	ldd	r17, Y+22	; 0x16
    17c4:	86 e0       	ldi	r24, 0x06	; 6
    17c6:	8c 83       	std	Y+4, r24	; 0x04
    17c8:	1a 83       	std	Y+2, r17	; 0x02
    17ca:	09 83       	std	Y+1, r16	; 0x01
    17cc:	8f ef       	ldi	r24, 0xFF	; 255
    17ce:	9f e7       	ldi	r25, 0x7F	; 127
    17d0:	9e 83       	std	Y+6, r25	; 0x06
    17d2:	8d 83       	std	Y+5, r24	; 0x05
    17d4:	ae 01       	movw	r20, r28
    17d6:	47 5e       	subi	r20, 0xE7	; 231
    17d8:	5f 4f       	sbci	r21, 0xFF	; 255
    17da:	6f 89       	ldd	r22, Y+23	; 0x17
    17dc:	78 8d       	ldd	r23, Y+24	; 0x18
    17de:	ce 01       	movw	r24, r28
    17e0:	01 96       	adiw	r24, 0x01	; 1
    17e2:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <vfprintf>
    17e6:	ef 81       	ldd	r30, Y+7	; 0x07
    17e8:	f8 85       	ldd	r31, Y+8	; 0x08
    17ea:	e0 0f       	add	r30, r16
    17ec:	f1 1f       	adc	r31, r17
    17ee:	10 82       	st	Z, r1
    17f0:	2e 96       	adiw	r28, 0x0e	; 14
    17f2:	e4 e0       	ldi	r30, 0x04	; 4
    17f4:	0c 94 c7 0e 	jmp	0x1d8e	; 0x1d8e <__epilogue_restores__+0x1c>

000017f8 <vfprintf>:
    17f8:	ab e0       	ldi	r26, 0x0B	; 11
    17fa:	b0 e0       	ldi	r27, 0x00	; 0
    17fc:	e2 e0       	ldi	r30, 0x02	; 2
    17fe:	fc e0       	ldi	r31, 0x0C	; 12
    1800:	0c 94 9d 0e 	jmp	0x1d3a	; 0x1d3a <__prologue_saves__>
    1804:	6c 01       	movw	r12, r24
    1806:	7b 01       	movw	r14, r22
    1808:	8a 01       	movw	r16, r20
    180a:	fc 01       	movw	r30, r24
    180c:	17 82       	std	Z+7, r1	; 0x07
    180e:	16 82       	std	Z+6, r1	; 0x06
    1810:	83 81       	ldd	r24, Z+3	; 0x03
    1812:	81 ff       	sbrs	r24, 1
    1814:	cc c1       	rjmp	.+920    	; 0x1bae <vfprintf+0x3b6>
    1816:	ce 01       	movw	r24, r28
    1818:	01 96       	adiw	r24, 0x01	; 1
    181a:	3c 01       	movw	r6, r24
    181c:	f6 01       	movw	r30, r12
    181e:	93 81       	ldd	r25, Z+3	; 0x03
    1820:	f7 01       	movw	r30, r14
    1822:	93 fd       	sbrc	r25, 3
    1824:	85 91       	lpm	r24, Z+
    1826:	93 ff       	sbrs	r25, 3
    1828:	81 91       	ld	r24, Z+
    182a:	7f 01       	movw	r14, r30
    182c:	88 23       	and	r24, r24
    182e:	09 f4       	brne	.+2      	; 0x1832 <vfprintf+0x3a>
    1830:	ba c1       	rjmp	.+884    	; 0x1ba6 <vfprintf+0x3ae>
    1832:	85 32       	cpi	r24, 0x25	; 37
    1834:	39 f4       	brne	.+14     	; 0x1844 <vfprintf+0x4c>
    1836:	93 fd       	sbrc	r25, 3
    1838:	85 91       	lpm	r24, Z+
    183a:	93 ff       	sbrs	r25, 3
    183c:	81 91       	ld	r24, Z+
    183e:	7f 01       	movw	r14, r30
    1840:	85 32       	cpi	r24, 0x25	; 37
    1842:	29 f4       	brne	.+10     	; 0x184e <vfprintf+0x56>
    1844:	b6 01       	movw	r22, r12
    1846:	90 e0       	ldi	r25, 0x00	; 0
    1848:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <fputc>
    184c:	e7 cf       	rjmp	.-50     	; 0x181c <vfprintf+0x24>
    184e:	91 2c       	mov	r9, r1
    1850:	21 2c       	mov	r2, r1
    1852:	31 2c       	mov	r3, r1
    1854:	ff e1       	ldi	r31, 0x1F	; 31
    1856:	f3 15       	cp	r31, r3
    1858:	d8 f0       	brcs	.+54     	; 0x1890 <vfprintf+0x98>
    185a:	8b 32       	cpi	r24, 0x2B	; 43
    185c:	79 f0       	breq	.+30     	; 0x187c <vfprintf+0x84>
    185e:	38 f4       	brcc	.+14     	; 0x186e <vfprintf+0x76>
    1860:	80 32       	cpi	r24, 0x20	; 32
    1862:	79 f0       	breq	.+30     	; 0x1882 <vfprintf+0x8a>
    1864:	83 32       	cpi	r24, 0x23	; 35
    1866:	a1 f4       	brne	.+40     	; 0x1890 <vfprintf+0x98>
    1868:	23 2d       	mov	r18, r3
    186a:	20 61       	ori	r18, 0x10	; 16
    186c:	1d c0       	rjmp	.+58     	; 0x18a8 <vfprintf+0xb0>
    186e:	8d 32       	cpi	r24, 0x2D	; 45
    1870:	61 f0       	breq	.+24     	; 0x188a <vfprintf+0x92>
    1872:	80 33       	cpi	r24, 0x30	; 48
    1874:	69 f4       	brne	.+26     	; 0x1890 <vfprintf+0x98>
    1876:	23 2d       	mov	r18, r3
    1878:	21 60       	ori	r18, 0x01	; 1
    187a:	16 c0       	rjmp	.+44     	; 0x18a8 <vfprintf+0xb0>
    187c:	83 2d       	mov	r24, r3
    187e:	82 60       	ori	r24, 0x02	; 2
    1880:	38 2e       	mov	r3, r24
    1882:	e3 2d       	mov	r30, r3
    1884:	e4 60       	ori	r30, 0x04	; 4
    1886:	3e 2e       	mov	r3, r30
    1888:	2a c0       	rjmp	.+84     	; 0x18de <vfprintf+0xe6>
    188a:	f3 2d       	mov	r31, r3
    188c:	f8 60       	ori	r31, 0x08	; 8
    188e:	1d c0       	rjmp	.+58     	; 0x18ca <vfprintf+0xd2>
    1890:	37 fc       	sbrc	r3, 7
    1892:	2d c0       	rjmp	.+90     	; 0x18ee <vfprintf+0xf6>
    1894:	20 ed       	ldi	r18, 0xD0	; 208
    1896:	28 0f       	add	r18, r24
    1898:	2a 30       	cpi	r18, 0x0A	; 10
    189a:	40 f0       	brcs	.+16     	; 0x18ac <vfprintf+0xb4>
    189c:	8e 32       	cpi	r24, 0x2E	; 46
    189e:	b9 f4       	brne	.+46     	; 0x18ce <vfprintf+0xd6>
    18a0:	36 fc       	sbrc	r3, 6
    18a2:	81 c1       	rjmp	.+770    	; 0x1ba6 <vfprintf+0x3ae>
    18a4:	23 2d       	mov	r18, r3
    18a6:	20 64       	ori	r18, 0x40	; 64
    18a8:	32 2e       	mov	r3, r18
    18aa:	19 c0       	rjmp	.+50     	; 0x18de <vfprintf+0xe6>
    18ac:	36 fe       	sbrs	r3, 6
    18ae:	06 c0       	rjmp	.+12     	; 0x18bc <vfprintf+0xc4>
    18b0:	8a e0       	ldi	r24, 0x0A	; 10
    18b2:	98 9e       	mul	r9, r24
    18b4:	20 0d       	add	r18, r0
    18b6:	11 24       	eor	r1, r1
    18b8:	92 2e       	mov	r9, r18
    18ba:	11 c0       	rjmp	.+34     	; 0x18de <vfprintf+0xe6>
    18bc:	ea e0       	ldi	r30, 0x0A	; 10
    18be:	2e 9e       	mul	r2, r30
    18c0:	20 0d       	add	r18, r0
    18c2:	11 24       	eor	r1, r1
    18c4:	22 2e       	mov	r2, r18
    18c6:	f3 2d       	mov	r31, r3
    18c8:	f0 62       	ori	r31, 0x20	; 32
    18ca:	3f 2e       	mov	r3, r31
    18cc:	08 c0       	rjmp	.+16     	; 0x18de <vfprintf+0xe6>
    18ce:	8c 36       	cpi	r24, 0x6C	; 108
    18d0:	21 f4       	brne	.+8      	; 0x18da <vfprintf+0xe2>
    18d2:	83 2d       	mov	r24, r3
    18d4:	80 68       	ori	r24, 0x80	; 128
    18d6:	38 2e       	mov	r3, r24
    18d8:	02 c0       	rjmp	.+4      	; 0x18de <vfprintf+0xe6>
    18da:	88 36       	cpi	r24, 0x68	; 104
    18dc:	41 f4       	brne	.+16     	; 0x18ee <vfprintf+0xf6>
    18de:	f7 01       	movw	r30, r14
    18e0:	93 fd       	sbrc	r25, 3
    18e2:	85 91       	lpm	r24, Z+
    18e4:	93 ff       	sbrs	r25, 3
    18e6:	81 91       	ld	r24, Z+
    18e8:	7f 01       	movw	r14, r30
    18ea:	81 11       	cpse	r24, r1
    18ec:	b3 cf       	rjmp	.-154    	; 0x1854 <vfprintf+0x5c>
    18ee:	98 2f       	mov	r25, r24
    18f0:	9f 7d       	andi	r25, 0xDF	; 223
    18f2:	95 54       	subi	r25, 0x45	; 69
    18f4:	93 30       	cpi	r25, 0x03	; 3
    18f6:	28 f4       	brcc	.+10     	; 0x1902 <vfprintf+0x10a>
    18f8:	0c 5f       	subi	r16, 0xFC	; 252
    18fa:	1f 4f       	sbci	r17, 0xFF	; 255
    18fc:	9f e3       	ldi	r25, 0x3F	; 63
    18fe:	99 83       	std	Y+1, r25	; 0x01
    1900:	0d c0       	rjmp	.+26     	; 0x191c <vfprintf+0x124>
    1902:	83 36       	cpi	r24, 0x63	; 99
    1904:	31 f0       	breq	.+12     	; 0x1912 <vfprintf+0x11a>
    1906:	83 37       	cpi	r24, 0x73	; 115
    1908:	71 f0       	breq	.+28     	; 0x1926 <vfprintf+0x12e>
    190a:	83 35       	cpi	r24, 0x53	; 83
    190c:	09 f0       	breq	.+2      	; 0x1910 <vfprintf+0x118>
    190e:	59 c0       	rjmp	.+178    	; 0x19c2 <vfprintf+0x1ca>
    1910:	21 c0       	rjmp	.+66     	; 0x1954 <vfprintf+0x15c>
    1912:	f8 01       	movw	r30, r16
    1914:	80 81       	ld	r24, Z
    1916:	89 83       	std	Y+1, r24	; 0x01
    1918:	0e 5f       	subi	r16, 0xFE	; 254
    191a:	1f 4f       	sbci	r17, 0xFF	; 255
    191c:	88 24       	eor	r8, r8
    191e:	83 94       	inc	r8
    1920:	91 2c       	mov	r9, r1
    1922:	53 01       	movw	r10, r6
    1924:	13 c0       	rjmp	.+38     	; 0x194c <vfprintf+0x154>
    1926:	28 01       	movw	r4, r16
    1928:	f2 e0       	ldi	r31, 0x02	; 2
    192a:	4f 0e       	add	r4, r31
    192c:	51 1c       	adc	r5, r1
    192e:	f8 01       	movw	r30, r16
    1930:	a0 80       	ld	r10, Z
    1932:	b1 80       	ldd	r11, Z+1	; 0x01
    1934:	36 fe       	sbrs	r3, 6
    1936:	03 c0       	rjmp	.+6      	; 0x193e <vfprintf+0x146>
    1938:	69 2d       	mov	r22, r9
    193a:	70 e0       	ldi	r23, 0x00	; 0
    193c:	02 c0       	rjmp	.+4      	; 0x1942 <vfprintf+0x14a>
    193e:	6f ef       	ldi	r22, 0xFF	; 255
    1940:	7f ef       	ldi	r23, 0xFF	; 255
    1942:	c5 01       	movw	r24, r10
    1944:	0e 94 e8 0d 	call	0x1bd0	; 0x1bd0 <strnlen>
    1948:	4c 01       	movw	r8, r24
    194a:	82 01       	movw	r16, r4
    194c:	f3 2d       	mov	r31, r3
    194e:	ff 77       	andi	r31, 0x7F	; 127
    1950:	3f 2e       	mov	r3, r31
    1952:	16 c0       	rjmp	.+44     	; 0x1980 <vfprintf+0x188>
    1954:	28 01       	movw	r4, r16
    1956:	22 e0       	ldi	r18, 0x02	; 2
    1958:	42 0e       	add	r4, r18
    195a:	51 1c       	adc	r5, r1
    195c:	f8 01       	movw	r30, r16
    195e:	a0 80       	ld	r10, Z
    1960:	b1 80       	ldd	r11, Z+1	; 0x01
    1962:	36 fe       	sbrs	r3, 6
    1964:	03 c0       	rjmp	.+6      	; 0x196c <vfprintf+0x174>
    1966:	69 2d       	mov	r22, r9
    1968:	70 e0       	ldi	r23, 0x00	; 0
    196a:	02 c0       	rjmp	.+4      	; 0x1970 <vfprintf+0x178>
    196c:	6f ef       	ldi	r22, 0xFF	; 255
    196e:	7f ef       	ldi	r23, 0xFF	; 255
    1970:	c5 01       	movw	r24, r10
    1972:	0e 94 dd 0d 	call	0x1bba	; 0x1bba <strnlen_P>
    1976:	4c 01       	movw	r8, r24
    1978:	f3 2d       	mov	r31, r3
    197a:	f0 68       	ori	r31, 0x80	; 128
    197c:	3f 2e       	mov	r3, r31
    197e:	82 01       	movw	r16, r4
    1980:	33 fc       	sbrc	r3, 3
    1982:	1b c0       	rjmp	.+54     	; 0x19ba <vfprintf+0x1c2>
    1984:	82 2d       	mov	r24, r2
    1986:	90 e0       	ldi	r25, 0x00	; 0
    1988:	88 16       	cp	r8, r24
    198a:	99 06       	cpc	r9, r25
    198c:	b0 f4       	brcc	.+44     	; 0x19ba <vfprintf+0x1c2>
    198e:	b6 01       	movw	r22, r12
    1990:	80 e2       	ldi	r24, 0x20	; 32
    1992:	90 e0       	ldi	r25, 0x00	; 0
    1994:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <fputc>
    1998:	2a 94       	dec	r2
    199a:	f4 cf       	rjmp	.-24     	; 0x1984 <vfprintf+0x18c>
    199c:	f5 01       	movw	r30, r10
    199e:	37 fc       	sbrc	r3, 7
    19a0:	85 91       	lpm	r24, Z+
    19a2:	37 fe       	sbrs	r3, 7
    19a4:	81 91       	ld	r24, Z+
    19a6:	5f 01       	movw	r10, r30
    19a8:	b6 01       	movw	r22, r12
    19aa:	90 e0       	ldi	r25, 0x00	; 0
    19ac:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <fputc>
    19b0:	21 10       	cpse	r2, r1
    19b2:	2a 94       	dec	r2
    19b4:	21 e0       	ldi	r18, 0x01	; 1
    19b6:	82 1a       	sub	r8, r18
    19b8:	91 08       	sbc	r9, r1
    19ba:	81 14       	cp	r8, r1
    19bc:	91 04       	cpc	r9, r1
    19be:	71 f7       	brne	.-36     	; 0x199c <vfprintf+0x1a4>
    19c0:	e8 c0       	rjmp	.+464    	; 0x1b92 <vfprintf+0x39a>
    19c2:	84 36       	cpi	r24, 0x64	; 100
    19c4:	11 f0       	breq	.+4      	; 0x19ca <vfprintf+0x1d2>
    19c6:	89 36       	cpi	r24, 0x69	; 105
    19c8:	41 f5       	brne	.+80     	; 0x1a1a <vfprintf+0x222>
    19ca:	f8 01       	movw	r30, r16
    19cc:	37 fe       	sbrs	r3, 7
    19ce:	07 c0       	rjmp	.+14     	; 0x19de <vfprintf+0x1e6>
    19d0:	60 81       	ld	r22, Z
    19d2:	71 81       	ldd	r23, Z+1	; 0x01
    19d4:	82 81       	ldd	r24, Z+2	; 0x02
    19d6:	93 81       	ldd	r25, Z+3	; 0x03
    19d8:	0c 5f       	subi	r16, 0xFC	; 252
    19da:	1f 4f       	sbci	r17, 0xFF	; 255
    19dc:	08 c0       	rjmp	.+16     	; 0x19ee <vfprintf+0x1f6>
    19de:	60 81       	ld	r22, Z
    19e0:	71 81       	ldd	r23, Z+1	; 0x01
    19e2:	07 2e       	mov	r0, r23
    19e4:	00 0c       	add	r0, r0
    19e6:	88 0b       	sbc	r24, r24
    19e8:	99 0b       	sbc	r25, r25
    19ea:	0e 5f       	subi	r16, 0xFE	; 254
    19ec:	1f 4f       	sbci	r17, 0xFF	; 255
    19ee:	f3 2d       	mov	r31, r3
    19f0:	ff 76       	andi	r31, 0x6F	; 111
    19f2:	3f 2e       	mov	r3, r31
    19f4:	97 ff       	sbrs	r25, 7
    19f6:	09 c0       	rjmp	.+18     	; 0x1a0a <vfprintf+0x212>
    19f8:	90 95       	com	r25
    19fa:	80 95       	com	r24
    19fc:	70 95       	com	r23
    19fe:	61 95       	neg	r22
    1a00:	7f 4f       	sbci	r23, 0xFF	; 255
    1a02:	8f 4f       	sbci	r24, 0xFF	; 255
    1a04:	9f 4f       	sbci	r25, 0xFF	; 255
    1a06:	f0 68       	ori	r31, 0x80	; 128
    1a08:	3f 2e       	mov	r3, r31
    1a0a:	2a e0       	ldi	r18, 0x0A	; 10
    1a0c:	30 e0       	ldi	r19, 0x00	; 0
    1a0e:	a3 01       	movw	r20, r6
    1a10:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <__ultoa_invert>
    1a14:	88 2e       	mov	r8, r24
    1a16:	86 18       	sub	r8, r6
    1a18:	45 c0       	rjmp	.+138    	; 0x1aa4 <vfprintf+0x2ac>
    1a1a:	85 37       	cpi	r24, 0x75	; 117
    1a1c:	31 f4       	brne	.+12     	; 0x1a2a <vfprintf+0x232>
    1a1e:	23 2d       	mov	r18, r3
    1a20:	2f 7e       	andi	r18, 0xEF	; 239
    1a22:	b2 2e       	mov	r11, r18
    1a24:	2a e0       	ldi	r18, 0x0A	; 10
    1a26:	30 e0       	ldi	r19, 0x00	; 0
    1a28:	25 c0       	rjmp	.+74     	; 0x1a74 <vfprintf+0x27c>
    1a2a:	93 2d       	mov	r25, r3
    1a2c:	99 7f       	andi	r25, 0xF9	; 249
    1a2e:	b9 2e       	mov	r11, r25
    1a30:	8f 36       	cpi	r24, 0x6F	; 111
    1a32:	c1 f0       	breq	.+48     	; 0x1a64 <vfprintf+0x26c>
    1a34:	18 f4       	brcc	.+6      	; 0x1a3c <vfprintf+0x244>
    1a36:	88 35       	cpi	r24, 0x58	; 88
    1a38:	79 f0       	breq	.+30     	; 0x1a58 <vfprintf+0x260>
    1a3a:	b5 c0       	rjmp	.+362    	; 0x1ba6 <vfprintf+0x3ae>
    1a3c:	80 37       	cpi	r24, 0x70	; 112
    1a3e:	19 f0       	breq	.+6      	; 0x1a46 <vfprintf+0x24e>
    1a40:	88 37       	cpi	r24, 0x78	; 120
    1a42:	21 f0       	breq	.+8      	; 0x1a4c <vfprintf+0x254>
    1a44:	b0 c0       	rjmp	.+352    	; 0x1ba6 <vfprintf+0x3ae>
    1a46:	e9 2f       	mov	r30, r25
    1a48:	e0 61       	ori	r30, 0x10	; 16
    1a4a:	be 2e       	mov	r11, r30
    1a4c:	b4 fe       	sbrs	r11, 4
    1a4e:	0d c0       	rjmp	.+26     	; 0x1a6a <vfprintf+0x272>
    1a50:	fb 2d       	mov	r31, r11
    1a52:	f4 60       	ori	r31, 0x04	; 4
    1a54:	bf 2e       	mov	r11, r31
    1a56:	09 c0       	rjmp	.+18     	; 0x1a6a <vfprintf+0x272>
    1a58:	34 fe       	sbrs	r3, 4
    1a5a:	0a c0       	rjmp	.+20     	; 0x1a70 <vfprintf+0x278>
    1a5c:	29 2f       	mov	r18, r25
    1a5e:	26 60       	ori	r18, 0x06	; 6
    1a60:	b2 2e       	mov	r11, r18
    1a62:	06 c0       	rjmp	.+12     	; 0x1a70 <vfprintf+0x278>
    1a64:	28 e0       	ldi	r18, 0x08	; 8
    1a66:	30 e0       	ldi	r19, 0x00	; 0
    1a68:	05 c0       	rjmp	.+10     	; 0x1a74 <vfprintf+0x27c>
    1a6a:	20 e1       	ldi	r18, 0x10	; 16
    1a6c:	30 e0       	ldi	r19, 0x00	; 0
    1a6e:	02 c0       	rjmp	.+4      	; 0x1a74 <vfprintf+0x27c>
    1a70:	20 e1       	ldi	r18, 0x10	; 16
    1a72:	32 e0       	ldi	r19, 0x02	; 2
    1a74:	f8 01       	movw	r30, r16
    1a76:	b7 fe       	sbrs	r11, 7
    1a78:	07 c0       	rjmp	.+14     	; 0x1a88 <vfprintf+0x290>
    1a7a:	60 81       	ld	r22, Z
    1a7c:	71 81       	ldd	r23, Z+1	; 0x01
    1a7e:	82 81       	ldd	r24, Z+2	; 0x02
    1a80:	93 81       	ldd	r25, Z+3	; 0x03
    1a82:	0c 5f       	subi	r16, 0xFC	; 252
    1a84:	1f 4f       	sbci	r17, 0xFF	; 255
    1a86:	06 c0       	rjmp	.+12     	; 0x1a94 <vfprintf+0x29c>
    1a88:	60 81       	ld	r22, Z
    1a8a:	71 81       	ldd	r23, Z+1	; 0x01
    1a8c:	80 e0       	ldi	r24, 0x00	; 0
    1a8e:	90 e0       	ldi	r25, 0x00	; 0
    1a90:	0e 5f       	subi	r16, 0xFE	; 254
    1a92:	1f 4f       	sbci	r17, 0xFF	; 255
    1a94:	a3 01       	movw	r20, r6
    1a96:	0e 94 3f 0e 	call	0x1c7e	; 0x1c7e <__ultoa_invert>
    1a9a:	88 2e       	mov	r8, r24
    1a9c:	86 18       	sub	r8, r6
    1a9e:	fb 2d       	mov	r31, r11
    1aa0:	ff 77       	andi	r31, 0x7F	; 127
    1aa2:	3f 2e       	mov	r3, r31
    1aa4:	36 fe       	sbrs	r3, 6
    1aa6:	0d c0       	rjmp	.+26     	; 0x1ac2 <vfprintf+0x2ca>
    1aa8:	23 2d       	mov	r18, r3
    1aaa:	2e 7f       	andi	r18, 0xFE	; 254
    1aac:	a2 2e       	mov	r10, r18
    1aae:	89 14       	cp	r8, r9
    1ab0:	58 f4       	brcc	.+22     	; 0x1ac8 <vfprintf+0x2d0>
    1ab2:	34 fe       	sbrs	r3, 4
    1ab4:	0b c0       	rjmp	.+22     	; 0x1acc <vfprintf+0x2d4>
    1ab6:	32 fc       	sbrc	r3, 2
    1ab8:	09 c0       	rjmp	.+18     	; 0x1acc <vfprintf+0x2d4>
    1aba:	83 2d       	mov	r24, r3
    1abc:	8e 7e       	andi	r24, 0xEE	; 238
    1abe:	a8 2e       	mov	r10, r24
    1ac0:	05 c0       	rjmp	.+10     	; 0x1acc <vfprintf+0x2d4>
    1ac2:	b8 2c       	mov	r11, r8
    1ac4:	a3 2c       	mov	r10, r3
    1ac6:	03 c0       	rjmp	.+6      	; 0x1ace <vfprintf+0x2d6>
    1ac8:	b8 2c       	mov	r11, r8
    1aca:	01 c0       	rjmp	.+2      	; 0x1ace <vfprintf+0x2d6>
    1acc:	b9 2c       	mov	r11, r9
    1ace:	a4 fe       	sbrs	r10, 4
    1ad0:	0f c0       	rjmp	.+30     	; 0x1af0 <vfprintf+0x2f8>
    1ad2:	fe 01       	movw	r30, r28
    1ad4:	e8 0d       	add	r30, r8
    1ad6:	f1 1d       	adc	r31, r1
    1ad8:	80 81       	ld	r24, Z
    1ada:	80 33       	cpi	r24, 0x30	; 48
    1adc:	21 f4       	brne	.+8      	; 0x1ae6 <vfprintf+0x2ee>
    1ade:	9a 2d       	mov	r25, r10
    1ae0:	99 7e       	andi	r25, 0xE9	; 233
    1ae2:	a9 2e       	mov	r10, r25
    1ae4:	09 c0       	rjmp	.+18     	; 0x1af8 <vfprintf+0x300>
    1ae6:	a2 fe       	sbrs	r10, 2
    1ae8:	06 c0       	rjmp	.+12     	; 0x1af6 <vfprintf+0x2fe>
    1aea:	b3 94       	inc	r11
    1aec:	b3 94       	inc	r11
    1aee:	04 c0       	rjmp	.+8      	; 0x1af8 <vfprintf+0x300>
    1af0:	8a 2d       	mov	r24, r10
    1af2:	86 78       	andi	r24, 0x86	; 134
    1af4:	09 f0       	breq	.+2      	; 0x1af8 <vfprintf+0x300>
    1af6:	b3 94       	inc	r11
    1af8:	a3 fc       	sbrc	r10, 3
    1afa:	11 c0       	rjmp	.+34     	; 0x1b1e <vfprintf+0x326>
    1afc:	a0 fe       	sbrs	r10, 0
    1afe:	06 c0       	rjmp	.+12     	; 0x1b0c <vfprintf+0x314>
    1b00:	b2 14       	cp	r11, r2
    1b02:	88 f4       	brcc	.+34     	; 0x1b26 <vfprintf+0x32e>
    1b04:	28 0c       	add	r2, r8
    1b06:	92 2c       	mov	r9, r2
    1b08:	9b 18       	sub	r9, r11
    1b0a:	0e c0       	rjmp	.+28     	; 0x1b28 <vfprintf+0x330>
    1b0c:	b2 14       	cp	r11, r2
    1b0e:	60 f4       	brcc	.+24     	; 0x1b28 <vfprintf+0x330>
    1b10:	b6 01       	movw	r22, r12
    1b12:	80 e2       	ldi	r24, 0x20	; 32
    1b14:	90 e0       	ldi	r25, 0x00	; 0
    1b16:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <fputc>
    1b1a:	b3 94       	inc	r11
    1b1c:	f7 cf       	rjmp	.-18     	; 0x1b0c <vfprintf+0x314>
    1b1e:	b2 14       	cp	r11, r2
    1b20:	18 f4       	brcc	.+6      	; 0x1b28 <vfprintf+0x330>
    1b22:	2b 18       	sub	r2, r11
    1b24:	02 c0       	rjmp	.+4      	; 0x1b2a <vfprintf+0x332>
    1b26:	98 2c       	mov	r9, r8
    1b28:	21 2c       	mov	r2, r1
    1b2a:	a4 fe       	sbrs	r10, 4
    1b2c:	10 c0       	rjmp	.+32     	; 0x1b4e <vfprintf+0x356>
    1b2e:	b6 01       	movw	r22, r12
    1b30:	80 e3       	ldi	r24, 0x30	; 48
    1b32:	90 e0       	ldi	r25, 0x00	; 0
    1b34:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <fputc>
    1b38:	a2 fe       	sbrs	r10, 2
    1b3a:	17 c0       	rjmp	.+46     	; 0x1b6a <vfprintf+0x372>
    1b3c:	a1 fc       	sbrc	r10, 1
    1b3e:	03 c0       	rjmp	.+6      	; 0x1b46 <vfprintf+0x34e>
    1b40:	88 e7       	ldi	r24, 0x78	; 120
    1b42:	90 e0       	ldi	r25, 0x00	; 0
    1b44:	02 c0       	rjmp	.+4      	; 0x1b4a <vfprintf+0x352>
    1b46:	88 e5       	ldi	r24, 0x58	; 88
    1b48:	90 e0       	ldi	r25, 0x00	; 0
    1b4a:	b6 01       	movw	r22, r12
    1b4c:	0c c0       	rjmp	.+24     	; 0x1b66 <vfprintf+0x36e>
    1b4e:	8a 2d       	mov	r24, r10
    1b50:	86 78       	andi	r24, 0x86	; 134
    1b52:	59 f0       	breq	.+22     	; 0x1b6a <vfprintf+0x372>
    1b54:	a1 fe       	sbrs	r10, 1
    1b56:	02 c0       	rjmp	.+4      	; 0x1b5c <vfprintf+0x364>
    1b58:	8b e2       	ldi	r24, 0x2B	; 43
    1b5a:	01 c0       	rjmp	.+2      	; 0x1b5e <vfprintf+0x366>
    1b5c:	80 e2       	ldi	r24, 0x20	; 32
    1b5e:	a7 fc       	sbrc	r10, 7
    1b60:	8d e2       	ldi	r24, 0x2D	; 45
    1b62:	b6 01       	movw	r22, r12
    1b64:	90 e0       	ldi	r25, 0x00	; 0
    1b66:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <fputc>
    1b6a:	89 14       	cp	r8, r9
    1b6c:	38 f4       	brcc	.+14     	; 0x1b7c <vfprintf+0x384>
    1b6e:	b6 01       	movw	r22, r12
    1b70:	80 e3       	ldi	r24, 0x30	; 48
    1b72:	90 e0       	ldi	r25, 0x00	; 0
    1b74:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <fputc>
    1b78:	9a 94       	dec	r9
    1b7a:	f7 cf       	rjmp	.-18     	; 0x1b6a <vfprintf+0x372>
    1b7c:	8a 94       	dec	r8
    1b7e:	f3 01       	movw	r30, r6
    1b80:	e8 0d       	add	r30, r8
    1b82:	f1 1d       	adc	r31, r1
    1b84:	80 81       	ld	r24, Z
    1b86:	b6 01       	movw	r22, r12
    1b88:	90 e0       	ldi	r25, 0x00	; 0
    1b8a:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <fputc>
    1b8e:	81 10       	cpse	r8, r1
    1b90:	f5 cf       	rjmp	.-22     	; 0x1b7c <vfprintf+0x384>
    1b92:	22 20       	and	r2, r2
    1b94:	09 f4       	brne	.+2      	; 0x1b98 <vfprintf+0x3a0>
    1b96:	42 ce       	rjmp	.-892    	; 0x181c <vfprintf+0x24>
    1b98:	b6 01       	movw	r22, r12
    1b9a:	80 e2       	ldi	r24, 0x20	; 32
    1b9c:	90 e0       	ldi	r25, 0x00	; 0
    1b9e:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <fputc>
    1ba2:	2a 94       	dec	r2
    1ba4:	f6 cf       	rjmp	.-20     	; 0x1b92 <vfprintf+0x39a>
    1ba6:	f6 01       	movw	r30, r12
    1ba8:	86 81       	ldd	r24, Z+6	; 0x06
    1baa:	97 81       	ldd	r25, Z+7	; 0x07
    1bac:	02 c0       	rjmp	.+4      	; 0x1bb2 <vfprintf+0x3ba>
    1bae:	8f ef       	ldi	r24, 0xFF	; 255
    1bb0:	9f ef       	ldi	r25, 0xFF	; 255
    1bb2:	2b 96       	adiw	r28, 0x0b	; 11
    1bb4:	e2 e1       	ldi	r30, 0x12	; 18
    1bb6:	0c 94 b9 0e 	jmp	0x1d72	; 0x1d72 <__epilogue_restores__>

00001bba <strnlen_P>:
    1bba:	fc 01       	movw	r30, r24
    1bbc:	05 90       	lpm	r0, Z+
    1bbe:	61 50       	subi	r22, 0x01	; 1
    1bc0:	70 40       	sbci	r23, 0x00	; 0
    1bc2:	01 10       	cpse	r0, r1
    1bc4:	d8 f7       	brcc	.-10     	; 0x1bbc <strnlen_P+0x2>
    1bc6:	80 95       	com	r24
    1bc8:	90 95       	com	r25
    1bca:	8e 0f       	add	r24, r30
    1bcc:	9f 1f       	adc	r25, r31
    1bce:	08 95       	ret

00001bd0 <strnlen>:
    1bd0:	fc 01       	movw	r30, r24
    1bd2:	61 50       	subi	r22, 0x01	; 1
    1bd4:	70 40       	sbci	r23, 0x00	; 0
    1bd6:	01 90       	ld	r0, Z+
    1bd8:	01 10       	cpse	r0, r1
    1bda:	d8 f7       	brcc	.-10     	; 0x1bd2 <strnlen+0x2>
    1bdc:	80 95       	com	r24
    1bde:	90 95       	com	r25
    1be0:	8e 0f       	add	r24, r30
    1be2:	9f 1f       	adc	r25, r31
    1be4:	08 95       	ret

00001be6 <strrev>:
    1be6:	dc 01       	movw	r26, r24
    1be8:	fc 01       	movw	r30, r24
    1bea:	67 2f       	mov	r22, r23
    1bec:	71 91       	ld	r23, Z+
    1bee:	77 23       	and	r23, r23
    1bf0:	e1 f7       	brne	.-8      	; 0x1bea <strrev+0x4>
    1bf2:	32 97       	sbiw	r30, 0x02	; 2
    1bf4:	04 c0       	rjmp	.+8      	; 0x1bfe <strrev+0x18>
    1bf6:	7c 91       	ld	r23, X
    1bf8:	6d 93       	st	X+, r22
    1bfa:	70 83       	st	Z, r23
    1bfc:	62 91       	ld	r22, -Z
    1bfe:	ae 17       	cp	r26, r30
    1c00:	bf 07       	cpc	r27, r31
    1c02:	c8 f3       	brcs	.-14     	; 0x1bf6 <strrev+0x10>
    1c04:	08 95       	ret

00001c06 <fputc>:
    1c06:	0f 93       	push	r16
    1c08:	1f 93       	push	r17
    1c0a:	cf 93       	push	r28
    1c0c:	df 93       	push	r29
    1c0e:	fb 01       	movw	r30, r22
    1c10:	23 81       	ldd	r18, Z+3	; 0x03
    1c12:	21 fd       	sbrc	r18, 1
    1c14:	03 c0       	rjmp	.+6      	; 0x1c1c <fputc+0x16>
    1c16:	8f ef       	ldi	r24, 0xFF	; 255
    1c18:	9f ef       	ldi	r25, 0xFF	; 255
    1c1a:	2c c0       	rjmp	.+88     	; 0x1c74 <fputc+0x6e>
    1c1c:	22 ff       	sbrs	r18, 2
    1c1e:	16 c0       	rjmp	.+44     	; 0x1c4c <fputc+0x46>
    1c20:	46 81       	ldd	r20, Z+6	; 0x06
    1c22:	57 81       	ldd	r21, Z+7	; 0x07
    1c24:	24 81       	ldd	r18, Z+4	; 0x04
    1c26:	35 81       	ldd	r19, Z+5	; 0x05
    1c28:	42 17       	cp	r20, r18
    1c2a:	53 07       	cpc	r21, r19
    1c2c:	44 f4       	brge	.+16     	; 0x1c3e <fputc+0x38>
    1c2e:	a0 81       	ld	r26, Z
    1c30:	b1 81       	ldd	r27, Z+1	; 0x01
    1c32:	9d 01       	movw	r18, r26
    1c34:	2f 5f       	subi	r18, 0xFF	; 255
    1c36:	3f 4f       	sbci	r19, 0xFF	; 255
    1c38:	31 83       	std	Z+1, r19	; 0x01
    1c3a:	20 83       	st	Z, r18
    1c3c:	8c 93       	st	X, r24
    1c3e:	26 81       	ldd	r18, Z+6	; 0x06
    1c40:	37 81       	ldd	r19, Z+7	; 0x07
    1c42:	2f 5f       	subi	r18, 0xFF	; 255
    1c44:	3f 4f       	sbci	r19, 0xFF	; 255
    1c46:	37 83       	std	Z+7, r19	; 0x07
    1c48:	26 83       	std	Z+6, r18	; 0x06
    1c4a:	14 c0       	rjmp	.+40     	; 0x1c74 <fputc+0x6e>
    1c4c:	8b 01       	movw	r16, r22
    1c4e:	ec 01       	movw	r28, r24
    1c50:	fb 01       	movw	r30, r22
    1c52:	00 84       	ldd	r0, Z+8	; 0x08
    1c54:	f1 85       	ldd	r31, Z+9	; 0x09
    1c56:	e0 2d       	mov	r30, r0
    1c58:	09 95       	icall
    1c5a:	89 2b       	or	r24, r25
    1c5c:	e1 f6       	brne	.-72     	; 0x1c16 <fputc+0x10>
    1c5e:	d8 01       	movw	r26, r16
    1c60:	16 96       	adiw	r26, 0x06	; 6
    1c62:	8d 91       	ld	r24, X+
    1c64:	9c 91       	ld	r25, X
    1c66:	17 97       	sbiw	r26, 0x07	; 7
    1c68:	01 96       	adiw	r24, 0x01	; 1
    1c6a:	17 96       	adiw	r26, 0x07	; 7
    1c6c:	9c 93       	st	X, r25
    1c6e:	8e 93       	st	-X, r24
    1c70:	16 97       	sbiw	r26, 0x06	; 6
    1c72:	ce 01       	movw	r24, r28
    1c74:	df 91       	pop	r29
    1c76:	cf 91       	pop	r28
    1c78:	1f 91       	pop	r17
    1c7a:	0f 91       	pop	r16
    1c7c:	08 95       	ret

00001c7e <__ultoa_invert>:
    1c7e:	fa 01       	movw	r30, r20
    1c80:	aa 27       	eor	r26, r26
    1c82:	28 30       	cpi	r18, 0x08	; 8
    1c84:	51 f1       	breq	.+84     	; 0x1cda <__ultoa_invert+0x5c>
    1c86:	20 31       	cpi	r18, 0x10	; 16
    1c88:	81 f1       	breq	.+96     	; 0x1cea <__ultoa_invert+0x6c>
    1c8a:	e8 94       	clt
    1c8c:	6f 93       	push	r22
    1c8e:	6e 7f       	andi	r22, 0xFE	; 254
    1c90:	6e 5f       	subi	r22, 0xFE	; 254
    1c92:	7f 4f       	sbci	r23, 0xFF	; 255
    1c94:	8f 4f       	sbci	r24, 0xFF	; 255
    1c96:	9f 4f       	sbci	r25, 0xFF	; 255
    1c98:	af 4f       	sbci	r26, 0xFF	; 255
    1c9a:	b1 e0       	ldi	r27, 0x01	; 1
    1c9c:	3e d0       	rcall	.+124    	; 0x1d1a <__ultoa_invert+0x9c>
    1c9e:	b4 e0       	ldi	r27, 0x04	; 4
    1ca0:	3c d0       	rcall	.+120    	; 0x1d1a <__ultoa_invert+0x9c>
    1ca2:	67 0f       	add	r22, r23
    1ca4:	78 1f       	adc	r23, r24
    1ca6:	89 1f       	adc	r24, r25
    1ca8:	9a 1f       	adc	r25, r26
    1caa:	a1 1d       	adc	r26, r1
    1cac:	68 0f       	add	r22, r24
    1cae:	79 1f       	adc	r23, r25
    1cb0:	8a 1f       	adc	r24, r26
    1cb2:	91 1d       	adc	r25, r1
    1cb4:	a1 1d       	adc	r26, r1
    1cb6:	6a 0f       	add	r22, r26
    1cb8:	71 1d       	adc	r23, r1
    1cba:	81 1d       	adc	r24, r1
    1cbc:	91 1d       	adc	r25, r1
    1cbe:	a1 1d       	adc	r26, r1
    1cc0:	20 d0       	rcall	.+64     	; 0x1d02 <__ultoa_invert+0x84>
    1cc2:	09 f4       	brne	.+2      	; 0x1cc6 <__ultoa_invert+0x48>
    1cc4:	68 94       	set
    1cc6:	3f 91       	pop	r19
    1cc8:	2a e0       	ldi	r18, 0x0A	; 10
    1cca:	26 9f       	mul	r18, r22
    1ccc:	11 24       	eor	r1, r1
    1cce:	30 19       	sub	r19, r0
    1cd0:	30 5d       	subi	r19, 0xD0	; 208
    1cd2:	31 93       	st	Z+, r19
    1cd4:	de f6       	brtc	.-74     	; 0x1c8c <__ultoa_invert+0xe>
    1cd6:	cf 01       	movw	r24, r30
    1cd8:	08 95       	ret
    1cda:	46 2f       	mov	r20, r22
    1cdc:	47 70       	andi	r20, 0x07	; 7
    1cde:	40 5d       	subi	r20, 0xD0	; 208
    1ce0:	41 93       	st	Z+, r20
    1ce2:	b3 e0       	ldi	r27, 0x03	; 3
    1ce4:	0f d0       	rcall	.+30     	; 0x1d04 <__ultoa_invert+0x86>
    1ce6:	c9 f7       	brne	.-14     	; 0x1cda <__ultoa_invert+0x5c>
    1ce8:	f6 cf       	rjmp	.-20     	; 0x1cd6 <__ultoa_invert+0x58>
    1cea:	46 2f       	mov	r20, r22
    1cec:	4f 70       	andi	r20, 0x0F	; 15
    1cee:	40 5d       	subi	r20, 0xD0	; 208
    1cf0:	4a 33       	cpi	r20, 0x3A	; 58
    1cf2:	18 f0       	brcs	.+6      	; 0x1cfa <__ultoa_invert+0x7c>
    1cf4:	49 5d       	subi	r20, 0xD9	; 217
    1cf6:	31 fd       	sbrc	r19, 1
    1cf8:	40 52       	subi	r20, 0x20	; 32
    1cfa:	41 93       	st	Z+, r20
    1cfc:	02 d0       	rcall	.+4      	; 0x1d02 <__ultoa_invert+0x84>
    1cfe:	a9 f7       	brne	.-22     	; 0x1cea <__ultoa_invert+0x6c>
    1d00:	ea cf       	rjmp	.-44     	; 0x1cd6 <__ultoa_invert+0x58>
    1d02:	b4 e0       	ldi	r27, 0x04	; 4
    1d04:	a6 95       	lsr	r26
    1d06:	97 95       	ror	r25
    1d08:	87 95       	ror	r24
    1d0a:	77 95       	ror	r23
    1d0c:	67 95       	ror	r22
    1d0e:	ba 95       	dec	r27
    1d10:	c9 f7       	brne	.-14     	; 0x1d04 <__ultoa_invert+0x86>
    1d12:	00 97       	sbiw	r24, 0x00	; 0
    1d14:	61 05       	cpc	r22, r1
    1d16:	71 05       	cpc	r23, r1
    1d18:	08 95       	ret
    1d1a:	9b 01       	movw	r18, r22
    1d1c:	ac 01       	movw	r20, r24
    1d1e:	0a 2e       	mov	r0, r26
    1d20:	06 94       	lsr	r0
    1d22:	57 95       	ror	r21
    1d24:	47 95       	ror	r20
    1d26:	37 95       	ror	r19
    1d28:	27 95       	ror	r18
    1d2a:	ba 95       	dec	r27
    1d2c:	c9 f7       	brne	.-14     	; 0x1d20 <__ultoa_invert+0xa2>
    1d2e:	62 0f       	add	r22, r18
    1d30:	73 1f       	adc	r23, r19
    1d32:	84 1f       	adc	r24, r20
    1d34:	95 1f       	adc	r25, r21
    1d36:	a0 1d       	adc	r26, r0
    1d38:	08 95       	ret

00001d3a <__prologue_saves__>:
    1d3a:	2f 92       	push	r2
    1d3c:	3f 92       	push	r3
    1d3e:	4f 92       	push	r4
    1d40:	5f 92       	push	r5
    1d42:	6f 92       	push	r6
    1d44:	7f 92       	push	r7
    1d46:	8f 92       	push	r8
    1d48:	9f 92       	push	r9
    1d4a:	af 92       	push	r10
    1d4c:	bf 92       	push	r11
    1d4e:	cf 92       	push	r12
    1d50:	df 92       	push	r13
    1d52:	ef 92       	push	r14
    1d54:	ff 92       	push	r15
    1d56:	0f 93       	push	r16
    1d58:	1f 93       	push	r17
    1d5a:	cf 93       	push	r28
    1d5c:	df 93       	push	r29
    1d5e:	cd b7       	in	r28, 0x3d	; 61
    1d60:	de b7       	in	r29, 0x3e	; 62
    1d62:	ca 1b       	sub	r28, r26
    1d64:	db 0b       	sbc	r29, r27
    1d66:	0f b6       	in	r0, 0x3f	; 63
    1d68:	f8 94       	cli
    1d6a:	de bf       	out	0x3e, r29	; 62
    1d6c:	0f be       	out	0x3f, r0	; 63
    1d6e:	cd bf       	out	0x3d, r28	; 61
    1d70:	09 94       	ijmp

00001d72 <__epilogue_restores__>:
    1d72:	2a 88       	ldd	r2, Y+18	; 0x12
    1d74:	39 88       	ldd	r3, Y+17	; 0x11
    1d76:	48 88       	ldd	r4, Y+16	; 0x10
    1d78:	5f 84       	ldd	r5, Y+15	; 0x0f
    1d7a:	6e 84       	ldd	r6, Y+14	; 0x0e
    1d7c:	7d 84       	ldd	r7, Y+13	; 0x0d
    1d7e:	8c 84       	ldd	r8, Y+12	; 0x0c
    1d80:	9b 84       	ldd	r9, Y+11	; 0x0b
    1d82:	aa 84       	ldd	r10, Y+10	; 0x0a
    1d84:	b9 84       	ldd	r11, Y+9	; 0x09
    1d86:	c8 84       	ldd	r12, Y+8	; 0x08
    1d88:	df 80       	ldd	r13, Y+7	; 0x07
    1d8a:	ee 80       	ldd	r14, Y+6	; 0x06
    1d8c:	fd 80       	ldd	r15, Y+5	; 0x05
    1d8e:	0c 81       	ldd	r16, Y+4	; 0x04
    1d90:	1b 81       	ldd	r17, Y+3	; 0x03
    1d92:	aa 81       	ldd	r26, Y+2	; 0x02
    1d94:	b9 81       	ldd	r27, Y+1	; 0x01
    1d96:	ce 0f       	add	r28, r30
    1d98:	d1 1d       	adc	r29, r1
    1d9a:	0f b6       	in	r0, 0x3f	; 63
    1d9c:	f8 94       	cli
    1d9e:	de bf       	out	0x3e, r29	; 62
    1da0:	0f be       	out	0x3f, r0	; 63
    1da2:	cd bf       	out	0x3d, r28	; 61
    1da4:	ed 01       	movw	r28, r26
    1da6:	08 95       	ret

00001da8 <_exit>:
    1da8:	f8 94       	cli

00001daa <__stop_program>:
    1daa:	ff cf       	rjmp	.-2      	; 0x1daa <__stop_program>
